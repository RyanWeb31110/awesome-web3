<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uniswap V1 数学原理可视化</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 36px;
        }
        
        h2 {
            color: #34495e;
            margin: 25px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }
        
        h3 {
            color: #34495e;
            margin: 20px 0 15px 0;
        }
        
        /* Canvas样式 */
        .canvas-container {
            position: relative;
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: white;
            cursor: crosshair;
        }
        
        /* 控制面板 */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        label {
            font-weight: bold;
            color: #34495e;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }
        
        input[type="number"] {
            padding: 10px;
            border: 2px solid #3498db;
            border-radius: 8px;
            font-size: 16px;
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        /* 信息展示 */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .info-card {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .info-value {
            font-size: 24px;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .info-label {
            font-size: 14px;
            opacity: 0.9;
        }
        
        /* 数学公式 */
        .formula-box {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
            font-size: 20px;
            font-family: 'Courier New', monospace;
        }
        
        .math-derivation {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }
        
        .math-step {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
        }
        
        /* 图例 */
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 30px;
            height: 3px;
        }
        
        /* 警告提示 */
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        /* 响应式 */
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="section">
            <h1>📊 Uniswap V1 恒定乘积公式数学原理</h1>
            
            <!-- 核心公式 -->
            <div class="formula-box">
                x · y = k (恒定乘积公式)
            </div>
            
            <!-- 主要图表：恒定乘积曲线 -->
            <h2>1. 恒定乘积曲线（双曲线）</h2>
            <div class="canvas-container">
                <canvas id="constantProductCanvas" width="800" height="500"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>恒定乘积曲线 (x·y=k)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>当前状态点</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>交易路径</span>
                    </div>
                </div>
            </div>
            
            <!-- 交互控制 -->
            <div class="controls">
                <div class="control-group">
                    <label>初始 ETH 数量：<span id="ethValue">10</span></label>
                    <input type="range" id="ethSlider" min="5" max="20" value="10" step="0.5">
                </div>
                <div class="control-group">
                    <label>初始 DAI 数量：<span id="daiValue">10000</span></label>
                    <input type="range" id="daiSlider" min="5000" max="20000" value="10000" step="500">
                </div>
                <div class="control-group">
                    <label>交易 ETH 数量：</label>
                    <input type="number" id="tradeAmount" value="1" min="-5" max="5" step="0.1">
                </div>
                <div class="control-group">
                    <button onclick="simulateTrade()">模拟交易</button>
                </div>
            </div>
            
            <!-- 实时数据展示 -->
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-label">常数 k</div>
                    <div class="info-value" id="kValue">100,000</div>
                </div>
                <div class="info-card">
                    <div class="info-label">当前价格</div>
                    <div class="info-value" id="currentPrice">1,000</div>
                    <div class="info-label">DAI/ETH</div>
                </div>
                <div class="info-card">
                    <div class="info-label">池中 ETH</div>
                    <div class="info-value" id="poolEth">10</div>
                </div>
                <div class="info-card">
                    <div class="info-label">池中 DAI</div>
                    <div class="info-value" id="poolDai">10,000</div>
                </div>
            </div>
        </div>
        
        <!-- 价格函数图表 -->
        <div class="section">
            <h2>2. 价格函数曲线</h2>
            <div class="canvas-container">
                <canvas id="priceCanvas" width="800" height="400"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>价格曲线 P(x) = k/x²</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e67e22;"></div>
                        <span>边际价格</span>
                    </div>
                </div>
            </div>
            
            <div class="math-derivation">
                <h3>价格推导：</h3>
                <div class="math-step">
                    <strong>步骤1：</strong> 从恒定乘积公式出发<br>
                    x · y = k
                </div>
                <div class="math-step">
                    <strong>步骤2：</strong> 表达y关于x的函数<br>
                    y = k / x
                </div>
                <div class="math-step">
                    <strong>步骤3：</strong> 价格定义（y相对于x的价格）<br>
                    P = dy/dx = -k/x²
                </div>
                <div class="math-step">
                    <strong>步骤4：</strong> 瞬时价格（现货价格）<br>
                    P_spot = y/x = k/(x·x) = k/x²
                </div>
            </div>
        </div>
        
        <!-- 滑点分析 -->
        <div class="section">
            <h2>3. 滑点分析（Price Impact）</h2>
            <div class="canvas-container">
                <canvas id="slippageCanvas" width="800" height="400"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>交易规模（占池子百分比）：<span id="tradeSizePercent">10</span>%</label>
                    <input type="range" id="tradeSizeSlider" min="1" max="50" value="10">
                </div>
            </div>
            
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-label">执行价格</div>
                    <div class="info-value" id="executionPrice">-</div>
                </div>
                <div class="info-card">
                    <div class="info-label">价格滑点</div>
                    <div class="info-value" id="priceSlippage">-</div>
                </div>
                <div class="info-card">
                    <div class="info-label">价格影响</div>
                    <div class="info-value" id="priceImpact">-</div>
                </div>
            </div>
        </div>
        
        <!-- 数学深度解析 -->
        <div class="section">
            <h2>4. 深度数学解析</h2>
            
            <h3>4.1 有效价格公式</h3>
            <div class="math-derivation">
                <div class="math-step">
                    <strong>场景：</strong>用 Δx 个 Token X 换取 Δy 个 Token Y<br><br>
                    <strong>交易前：</strong> x₀ · y₀ = k<br>
                    <strong>交易后：</strong> (x₀ + Δx) · (y₀ - Δy) = k<br><br>
                    <strong>求解 Δy：</strong><br>
                    Δy = y₀ - k/(x₀ + Δx)<br>
                    Δy = y₀ - y₀·x₀/(x₀ + Δx)<br>
                    Δy = y₀ · Δx/(x₀ + Δx)<br><br>
                    <strong>有效价格：</strong><br>
                    P_effective = Δy/Δx = y₀/(x₀ + Δx)
                </div>
            </div>
            
            <h3>4.2 考虑手续费的公式</h3>
            <div class="math-derivation">
                <div class="math-step">
                    <strong>Uniswap V1 手续费：</strong> 0.3%<br><br>
                    <strong>实际公式：</strong><br>
                    输入金额（含费）: input_with_fee = input_amount × 997<br>
                    分母: denominator = reserve_in × 1000 + input_with_fee<br>
                    输出金额: output_amount = (input_with_fee × reserve_out) / denominator<br><br>
                    <strong>简化表示：</strong><br>
                    Δy = 0.997 · Δx · y₀ / (x₀ + 0.997 · Δx)
                </div>
            </div>
            
            <h3>4.3 无常损失推导</h3>
            <div class="math-derivation">
                <div class="math-step">
                    <strong>定义：</strong><br>
                    IL = (HODL价值 - LP价值) / HODL价值<br><br>
                    
                    <strong>设价格变化比率 r = P₁/P₀：</strong><br>
                    IL = 2√r / (1 + r) - 1<br><br>
                    
                    <strong>常见场景：</strong><br>
                    • 价格变化 1.5x → IL ≈ 2.0%<br>
                    • 价格变化 2x → IL ≈ 5.7%<br>
                    • 价格变化 3x → IL ≈ 13.4%<br>
                    • 价格变化 5x → IL ≈ 25.5%
                </div>
            </div>
        </div>
        
        <!-- 实际案例分析 -->
        <div class="section">
            <h2>5. 实际交易案例分析</h2>
            
            <h3>案例：大额交易的价格影响</h3>
            <div class="controls">
                <div class="control-group">
                    <label>池子规模（ETH）：</label>
                    <input type="number" id="poolSize" value="100">
                </div>
                <div class="control-group">
                    <label>交易数量（ETH）：</label>
                    <input type="number" id="tradeSize" value="10">
                </div>
                <div class="control-group">
                    <button onclick="calculateRealCase()">计算影响</button>
                </div>
            </div>
            
            <div id="caseResult" class="math-derivation" style="display: none;">
                <!-- 动态填充 -->
            </div>
        </div>
        
        <!-- 关键洞察 -->
        <div class="section">
            <h2>6. 关键洞察与结论</h2>
            
            <div class="warning">
                <h3>⚠️ 重要观察：</h3>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li>恒定乘积曲线是一条双曲线，永远不会触及坐标轴</li>
                    <li>价格滑点与交易规模呈非线性关系</li>
                    <li>大额交易的实际价格会显著偏离初始报价</li>
                    <li>流动性越深，相同交易的滑点越小</li>
                </ul>
            </div>
            
            <div style="margin-top: 20px; padding: 20px; background: #e8f8f5; border-radius: 10px;">
                <h3>💡 核心优势：</h3>
                <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                    <li><strong>简单性：</strong>一个公式解决所有定价问题</li>
                    <li><strong>连续性：</strong>价格连续变化，没有跳跃</li>
                    <li><strong>自动平衡：</strong>套利者自动维持价格均衡</li>
                    <li><strong>无限流动性：</strong>理论上可以在任何价格交易（虽然滑点可能很大）</li>
                </ul>
            </div>
        </div>
    </div>
    
    <script>
        // 全局变量
        let ethReserve = 10;
        let daiReserve = 10000;
        let k = ethReserve * daiReserve;
        
        // 更新滑块显示
        document.getElementById('ethSlider').addEventListener('input', function(e) {
            ethReserve = parseFloat(e.target.value);
            document.getElementById('ethValue').textContent = ethReserve;
            updateK();
            drawAllCharts();
        });
        
        document.getElementById('daiSlider').addEventListener('input', function(e) {
            daiReserve = parseFloat(e.target.value);
            document.getElementById('daiValue').textContent = daiReserve;
            updateK();
            drawAllCharts();
        });
        
        document.getElementById('tradeSizeSlider').addEventListener('input', function(e) {
            document.getElementById('tradeSizePercent').textContent = e.target.value;
            drawSlippageChart();
        });
        
        function updateK() {
            k = ethReserve * daiReserve;
            document.getElementById('kValue').textContent = k.toLocaleString();
            document.getElementById('currentPrice').textContent = (daiReserve / ethReserve).toFixed(2);
            document.getElementById('poolEth').textContent = ethReserve.toFixed(2);
            document.getElementById('poolDai').textContent = daiReserve.toLocaleString();
        }
        
        // 绘制恒定乘积曲线
        function drawConstantProductCurve() {
            const canvas = document.getElementById('constantProductCanvas');
            const ctx = canvas.getContext('2d');
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 设置坐标系
            const padding = 60;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // 绘制坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();
            
            // 坐标轴标签
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('ETH (x)', padding + width - 40, padding + height + 30);
            ctx.save();
            ctx.translate(20, padding + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('DAI (y)', 0, 0);
            ctx.restore();
            
            // 计算缩放比例
            const maxX = ethReserve * 3;
            const maxY = daiReserve * 3;
            const scaleX = width / maxX;
            const scaleY = height / maxY;
            
            // 绘制双曲线 x*y = k
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let x = 0.1; x <= maxX; x += 0.1) {
                const y = k / x;
                if (y <= maxY) {
                    const px = padding + x * scaleX;
                    const py = padding + height - y * scaleY;
                    
                    if (x === 0.1) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
            }
            ctx.stroke();
            
            // 标记当前点
            const currentX = padding + ethReserve * scaleX;
            const currentY = padding + height - daiReserve * scaleY;
            
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制网格
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([5, 5]);
            
            // 垂直网格线
            for (let i = 1; i <= 10; i++) {
                const x = padding + (width * i / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + height);
                ctx.stroke();
            }
            
            // 水平网格线
            for (let i = 1; i <= 10; i++) {
                const y = padding + (height * i / 10);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + width, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // 添加数值标签
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            
            // X轴标签
            for (let i = 0; i <= 5; i++) {
                const value = (maxX * i / 5).toFixed(0);
                const x = padding + (width * i / 5);
                ctx.fillText(value, x - 10, padding + height + 20);
            }
            
            // Y轴标签
            for (let i = 0; i <= 5; i++) {
                const value = (maxY * i / 5).toFixed(0);
                const y = padding + height - (height * i / 5);
                ctx.fillText(value, padding - 45, y + 5);
            }
            
            // 添加公式标注
            ctx.fillStyle = '#3498db';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`x · y = ${k.toLocaleString()}`, padding + width/2 - 60, padding - 20);
        }
        
        // 绘制价格曲线
        function drawPriceCurve() {
            const canvas = document.getElementById('priceCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const padding = 60;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();
            
            // 坐标轴标签
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('ETH数量 (x)', padding + width - 50, padding + height + 30);
            ctx.save();
            ctx.translate(20, padding + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('价格 P(x) = k/x²', 0, 0);
            ctx.restore();
            
            const maxX = ethReserve * 3;
            const minX = ethReserve * 0.1;
            const scaleX = width / (maxX - minX);
            
            // 计算价格范围
            const maxPrice = k / (minX * minX);
            const minPrice = k / (maxX * maxX);
            const scaleY = height / (maxPrice - minPrice);
            
            // 绘制价格曲线 P = k/x²
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let x = minX; x <= maxX; x += 0.1) {
                const price = k / (x * x);
                const px = padding + (x - minX) * scaleX;
                const py = padding + height - (price - minPrice) * scaleY;
                
                if (x === minX) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            
            // 标记当前价格点
            const currentPrice = k / (ethReserve * ethReserve);
            const currentPx = padding + (ethReserve - minX) * scaleX;
            const currentPy = padding + height - (currentPrice - minPrice) * scaleY;
            
            ctx.fillStyle = '#e67e22';
            ctx.beginPath();
            ctx.arc(currentPx, currentPy, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // 添加价格标注
            ctx.fillStyle = '#e67e22';
            ctx.font = '14px Arial';
            ctx.fillText(`当前价格: ${(daiReserve/ethReserve).toFixed(2)} DAI/ETH`, currentPx + 15, currentPy - 10);
        }
        
        // 绘制滑点图表
        function drawSlippageChart() {
            const canvas = document.getElementById('slippageCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const padding = 60;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + height);
            ctx.lineTo(padding + width, padding + height);
            ctx.stroke();
            
            // 获取交易规模
            const tradeSizePercent = parseFloat(document.getElementById('tradeSizeSlider').value);
            const tradeAmount = ethReserve * tradeSizePercent / 100;
            
            // 计算滑点数据
            const steps = 50;
            const maxTrade = ethReserve * 0.5;
            const slippageData = [];
            
            for (let i = 0; i <= steps; i++) {
                const trade = (maxTrade * i) / steps;
                const newEth = ethReserve - trade;
                const newDai = k / newEth;
                const daiNeeded = newDai - daiReserve;
                
                const spotPrice = daiReserve / ethReserve;
                const executionPrice = daiNeeded / trade;
                const slippage = ((executionPrice - spotPrice) / spotPrice) * 100;
                
                slippageData.push({
                    trade: trade,
                    slippage: slippage
                });
            }
            
            // 绘制滑点曲线
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            const maxSlippage = 100;
            slippageData.forEach((point, i) => {
                const x = padding + (point.trade / maxTrade) * width;
                const y = padding + height - (point.slippage / maxSlippage) * height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // 标记当前交易点
            const currentNewEth = ethReserve - tradeAmount;
            const currentNewDai = k / currentNewEth;
            const currentDaiNeeded = currentNewDai - daiReserve;
            const currentSpotPrice = daiReserve / ethReserve;
            const currentExecutionPrice = currentDaiNeeded / tradeAmount;
            const currentSlippage = ((currentExecutionPrice - currentSpotPrice) / currentSpotPrice) * 100;
            
            const currentX = padding + (tradeAmount / maxTrade) * width;
            const currentY = padding + height - (currentSlippage / maxSlippage) * height;
            
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // 更新信息卡片
            document.getElementById('executionPrice').textContent = currentExecutionPrice.toFixed(2);
            document.getElementById('priceSlippage').textContent = currentSlippage.toFixed(2) + '%';
            document.getElementById('priceImpact').textContent = ((currentNewDai/currentNewEth - currentSpotPrice) / currentSpotPrice * 100).toFixed(2) + '%';
            
            // 添加标签
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('交易量 (ETH)', padding + width - 50, padding + height + 30);
            ctx.save();
            ctx.translate(20, padding + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('滑点 (%)', 0, 0);
            ctx.restore();
        }
        
        // 模拟交易
        function simulateTrade() {
            const tradeAmount = parseFloat(document.getElementById('tradeAmount').value);
            
            if (tradeAmount > 0) {
                // 买入ETH（卖出DAI）
                const newEth = ethReserve - tradeAmount;
                if (newEth <= 0) {
                    alert('交易量过大！');
                    return;
                }
                const newDai = k / newEth;
                
                // 绘制交易路径
                const canvas = document.getElementById('constantProductCanvas');
                const ctx = canvas.getContext('2d');
                
                const padding = 60;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                const maxX = ethReserve * 3;
                const maxY = daiReserve * 3;
                const scaleX = width / maxX;
                const scaleY = height / maxY;
                
                // 绘制交易路径（绿色箭头）
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(padding + ethReserve * scaleX, padding + height - daiReserve * scaleY);
                ctx.lineTo(padding + newEth * scaleX, padding + height - newDai * scaleY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 更新储备
                ethReserve = newEth;
                daiReserve = newDai;
            } else if (tradeAmount < 0) {
                // 卖出ETH（买入DAI）
                const newEth = ethReserve - tradeAmount;
                const newDai = k / newEth;
                
                ethReserve = newEth;
                daiReserve = newDai;
            }
            
            updateK();
            setTimeout(() => drawAllCharts(), 500);
        }
        
        // 计算实际案例
        function calculateRealCase() {
            const poolSize = parseFloat(document.getElementById('poolSize').value);
            const tradeSize = parseFloat(document.getElementById('tradeSize').value);
            
            const poolDai = poolSize * 2000; // 假设1 ETH = 2000 DAI
            const k = poolSize * poolDai;
            
            const newEth = poolSize - tradeSize;
            const newDai = k / newEth;
            const daiNeeded = newDai - poolDai;
            
            const spotPrice = poolDai / poolSize;
            const executionPrice = daiNeeded / tradeSize;
            const slippage = ((executionPrice - spotPrice) / spotPrice) * 100;
            
            const resultDiv = document.getElementById('caseResult');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = `
                <h3>计算结果：</h3>
                <div class="math-step">
                    <strong>初始状态：</strong><br>
                    池中 ETH: ${poolSize}<br>
                    池中 DAI: ${poolDai.toLocaleString()}<br>
                    k = ${k.toLocaleString()}<br>
                    现货价格: ${spotPrice.toFixed(2)} DAI/ETH
                </div>
                <div class="math-step">
                    <strong>交易执行：</strong><br>
                    购买 ETH: ${tradeSize}<br>
                    交易后 ETH: ${newEth}<br>
                    交易后 DAI: ${newDai.toFixed(2)}<br>
                    需要支付 DAI: ${daiNeeded.toFixed(2)}
                </div>
                <div class="math-step">
                    <strong>价格影响：</strong><br>
                    执行价格: ${executionPrice.toFixed(2)} DAI/ETH<br>
                    价格滑点: ${slippage.toFixed(2)}%<br>
                    新现货价格: ${(newDai/newEth).toFixed(2)} DAI/ETH
                </div>
                <div class="math-step" style="background: #fff3cd;">
                    <strong>💡 洞察：</strong><br>
                    ${slippage > 10 ? '⚠️ 滑点过大！建议分批交易或寻找更深的流动性池。' : 
                      slippage > 5 ? '滑点适中，可以接受但需注意。' : 
                      '滑点较小，交易条件良好。'}
                </div>
            `;
        }
        
        // 绘制所有图表
        function drawAllCharts() {
            drawConstantProductCurve();
            drawPriceCurve();
            drawSlippageChart();
        }
        
        // 初始化
        updateK();
        drawAllCharts();
    </script>
</body>
</html>