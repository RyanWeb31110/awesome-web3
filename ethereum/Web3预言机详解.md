# È¢ÑË®ÄÊú∫ÔºàOracleÔºâÔºöËøûÊé•Âå∫ÂùóÈìæ‰∏éÁé∞ÂÆû‰∏ñÁïåÁöÑÊ°•Ê¢Å

**È¢ÑË®ÄÊú∫ÔºàOracleÔºâ**ÊòØËøûÊé•Âå∫ÂùóÈìæ‰∏éÂ§ñÈÉ®‰∏ñÁïåÁöÑÊ°•Ê¢ÅÔºåÂÆÉË¥üË¥£Â∞ÜÈìæÂ§ñÊï∞ÊçÆÔºàÂ¶Ç‰ª∑Ê†º‰ø°ÊÅØ„ÄÅÂ§©Ê∞îÊï∞ÊçÆ„ÄÅ‰ΩìËÇ≤Ëµõ‰∫ãÁªìÊûúÁ≠âÔºâÂèØ‰ø°Âú∞‰º†ËæìÂà∞Âå∫ÂùóÈìæ‰∏äÔºå‰æõÊô∫ËÉΩÂêàÁ∫¶‰ΩøÁî®„ÄÇ

### ‰∏∫‰ªÄ‰πàÈúÄË¶ÅÈ¢ÑË®ÄÊú∫Ôºü

**Âå∫ÂùóÈìæÊï∞ÊçÆËÆøÈóÆÂØπÊØîÔºö**

| Êï∞ÊçÆÁ±ªÂûã | Âå∫ÂùóÈìæÂÜÖÈÉ® | Â§ñÈÉ®‰∏ñÁïå | ÂèØÁõ¥Êé•ËÆøÈóÆ | ËØ¥Êòé |
|---------|-----------|----------|-----------|------|
| ‰∫§ÊòìÊï∞ÊçÆ | ‚úÖ ÂèØÁî® | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÊòØ | Âå∫ÂùóÈìæÂéüÁîüÊï∞ÊçÆÔºåÂèØÁõ¥Êé•Êü•ËØ¢ |
| Êô∫ËÉΩÂêàÁ∫¶Áä∂ÊÄÅ | ‚úÖ ÂèØÁî® | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÊòØ | ÂêàÁ∫¶ÂÜÖÈÉ®ÂèòÈáèÂíåÁä∂ÊÄÅ |
| Ë¥¶Êà∑‰ΩôÈ¢ù | ‚úÖ ÂèØÁî® | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÊòØ | Èìæ‰∏äË¥¶Êà∑ÁöÑ‰ª£Â∏Å‰ΩôÈ¢ù |
| Âå∫Âùó‰ø°ÊÅØ | ‚úÖ ÂèØÁî® | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÊòØ | Âå∫ÂùóÈ´òÂ∫¶„ÄÅÊó∂Èó¥Êà≥„ÄÅÂìàÂ∏åÁ≠â |
| **ÂÆûÊó∂‰ª∑Ê†ºÊï∞ÊçÆ** | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÂèØÁî® | ‚ùå **ÈúÄË¶ÅÈ¢ÑË®ÄÊú∫** | Êù•Ëá™‰∫§ÊòìÊâÄÁöÑ‰ª∑Ê†º‰ø°ÊÅØ |
| **Â§©Ê∞î‰ø°ÊÅØ** | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÂèØÁî® | ‚ùå **ÈúÄË¶ÅÈ¢ÑË®ÄÊú∫** | Ê∞îË±°Êï∞ÊçÆAPI |
| **‰ΩìËÇ≤Ëµõ‰∫ãÁªìÊûú** | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÂèØÁî® | ‚ùå **ÈúÄË¶ÅÈ¢ÑË®ÄÊú∫** | ÊØîËµõÁªìÊûúÂíåÁªüËÆ°Êï∞ÊçÆ |
| **ÈöèÊú∫Êï∞** | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÂèØÁî® | ‚ùå **ÈúÄË¶ÅÈ¢ÑË®ÄÊú∫** | ÁúüÈöèÊú∫Êï∞ÁîüÊàê |
| **APIÊï∞ÊçÆ** | ‚ùå ‰∏çÂèØÁî® | ‚úÖ ÂèØÁî® | ‚ùå **ÈúÄË¶ÅÈ¢ÑË®ÄÊú∫** | Á¨¨‰∏âÊñπÊúçÂä°Êï∞ÊçÆ |

**È¢ÑË®ÄÊú∫ÁöÑÊ°•Ê¢Å‰ΩúÁî®Ôºö** üîÆ Oracle ËøûÊé•Âå∫ÂùóÈìæÂÜÖÈÉ®‰∏éÂ§ñÈÉ®‰∏ñÁïåÔºå‰ΩøÊô∫ËÉΩÂêàÁ∫¶ËÉΩÂ§üËÆøÈóÆÈìæÂ§ñÊï∞ÊçÆ

**Âå∫ÂùóÈìæÁöÑÁ°ÆÂÆöÊÄß**ÔºöÂå∫ÂùóÈìæËÆæËÆ°‰∏∫Á°ÆÂÆöÊÄßÁ≥ªÁªüÔºåÁõ∏ÂêåËæìÂÖ•ÂøÖÈ°ª‰∫ßÁîüÁõ∏ÂêåËæìÂá∫ÔºåÂõ†Ê≠§Êó†Ê≥ïÁõ¥Êé•ËÆøÈóÆ‰∏çÁ°ÆÂÆöÁöÑÂ§ñÈÉ®Êï∞ÊçÆ„ÄÇ

### È¢ÑË®ÄÊú∫ÁöÑÊ†∏ÂøÉÂäüËÉΩ

```solidity
// È¢ÑË®ÄÊú∫Êé•Âè£Á§∫‰æã
interface IOracle {
    // Ëé∑ÂèñÊï∞ÊçÆ
    function getPrice(string memory symbol) external view returns (uint256);
    
    // Êï∞ÊçÆÊõ¥Êñ∞
    function updatePrice(string memory symbol, uint256 price) external;
    
    // Êï∞ÊçÆÈ™åËØÅ
    function validateData(bytes memory data, bytes memory proof) external pure returns (bool);
    
    // ËÅöÂêàÂ§öÊï∞ÊçÆÊ∫ê
    function aggregateData(uint256[] memory prices) external pure returns (uint256);
}

// Âü∫Á°ÄÈ¢ÑË®ÄÊú∫ÂÆûÁé∞
contract BasicOracle is IOracle {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        address updater;
        bool isValid;
    }
    
    mapping(string => PriceData) public prices;
    mapping(address => bool) public authorizedUpdaters;
    
    modifier onlyAuthorized() {
        require(authorizedUpdaters[msg.sender], "Not authorized");
        _;
    }
    
    function updatePrice(string memory symbol, uint256 price) 
        external 
        onlyAuthorized 
    {
        prices[symbol] = PriceData({
            price: price,
            timestamp: block.timestamp,
            updater: msg.sender,
            isValid: true
        });
        
        emit PriceUpdated(symbol, price, block.timestamp);
    }
    
    function getPrice(string memory symbol) 
        external 
        view 
        returns (uint256) 
    {
        PriceData memory data = prices[symbol];
        require(data.isValid, "Price not available");
        require(block.timestamp - data.timestamp < 3600, "Price too old");
        
        return data.price;
    }
    
    event PriceUpdated(string symbol, uint256 price, uint256 timestamp);
}
```



## È¢ÑË®ÄÊú∫ÁöÑÂàÜÁ±ª‰ΩìÁ≥ª

### 1. ÊåâÊï∞ÊçÆÊ∫êÂàÜÁ±ª

#### ‰∏≠ÂøÉÂåñÈ¢ÑË®ÄÊú∫
```
ÁâπÁÇπÔºö
‚îú‚îÄ‚îÄ Âçï‰∏ÄÊï∞ÊçÆÊ∫ê
‚îú‚îÄ‚îÄ ‰ø°‰ªªÁ¨¨‰∏âÊñπ
‚îú‚îÄ‚îÄ Êõ¥Êñ∞ÈÄüÂ∫¶Âø´
‚îî‚îÄ‚îÄ ÂçïÁÇπÊïÖÈöúÈ£éÈô©

ÈÄÇÁî®Âú∫ÊôØÔºö
‚îú‚îÄ‚îÄ ÊµãËØïÁéØÂ¢É
‚îú‚îÄ‚îÄ ‰ΩéÈ£éÈô©Â∫îÁî®
‚îî‚îÄ‚îÄ Âø´ÈÄüÂéüÂûãÂºÄÂèë
```

```solidity
contract CentralizedOracle {
    address public dataProvider;
    mapping(string => uint256) public data;
    
    constructor(address _provider) {
        dataProvider = _provider;
    }
    
    modifier onlyProvider() {
        require(msg.sender == dataProvider, "Unauthorized");
        _;
    }
    
    function updateData(string memory key, uint256 value) 
        external 
        onlyProvider 
    {
        data[key] = value;
        emit DataUpdated(key, value);
    }
}
```

#### Âéª‰∏≠ÂøÉÂåñÈ¢ÑË®ÄÊú∫
```
ÁâπÁÇπÔºö
‚îú‚îÄ‚îÄ Â§ö‰∏™Êï∞ÊçÆÊ∫ê
‚îú‚îÄ‚îÄ ÂÖ±ËØÜÊú∫Âà∂
‚îú‚îÄ‚îÄ ÊäóÂÆ°Êü•ËÉΩÂäõÂº∫
‚îî‚îÄ‚îÄ Â§çÊùÇÂ∫¶ËæÉÈ´ò

‰ºòÂäøÔºö
‚îú‚îÄ‚îÄ Êó†ÂçïÁÇπÊïÖÈöú
‚îú‚îÄ‚îÄ Êï∞ÊçÆÂèØ‰ø°Â∫¶È´ò
‚îú‚îÄ‚îÄ ÊäóÊìçÁ∫µËÉΩÂäõÂº∫
‚îî‚îÄ‚îÄ Á¨¶ÂêàÂå∫ÂùóÈìæÁ≤æÁ•û
```

```solidity
contract DecentralizedOracle {
    struct DataFeed {
        mapping(address => uint256) submissions;
        address[] oracles;
        uint256 aggregatedValue;
        uint256 lastUpdate;
        uint8 minResponses;
    }
    
    mapping(string => DataFeed) public dataFeeds;
    mapping(address => bool) public authorizedOracles;
    
    function submitData(string memory feedId, uint256 value) external {
        require(authorizedOracles[msg.sender], "Not authorized");
        
        DataFeed storage feed = dataFeeds[feedId];
        
        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Êèê‰∫§
        require(feed.submissions[msg.sender] == 0, "Already submitted");
        
        feed.submissions[msg.sender] = value;
        feed.oracles.push(msg.sender);
        
        // Â¶ÇÊûúÊî∂ÈõÜÂà∞Ë∂≥Â§üÁöÑÂìçÂ∫îÔºåËøõË°åËÅöÂêà
        if (feed.oracles.length >= feed.minResponses) {
            aggregateData(feedId);
        }
        
        emit DataSubmitted(feedId, msg.sender, value);
    }
    
    function aggregateData(string memory feedId) internal {
        DataFeed storage feed = dataFeeds[feedId];
        
        // Êî∂ÈõÜÊâÄÊúâÊèê‰∫§ÁöÑÂÄº
        uint256[] memory values = new uint256[](feed.oracles.length);
        for (uint i = 0; i < feed.oracles.length; i++) {
            values[i] = feed.submissions[feed.oracles[i]];
        }
        
        // ËÆ°ÁÆó‰∏≠‰ΩçÊï∞
        feed.aggregatedValue = calculateMedian(values);
        feed.lastUpdate = block.timestamp;
        
        // Ê∏ÖÁêÜÊú¨ËΩÆÊï∞ÊçÆ
        for (uint i = 0; i < feed.oracles.length; i++) {
            delete feed.submissions[feed.oracles[i]];
        }
        delete feed.oracles;
        
        emit DataAggregated(feedId, feed.aggregatedValue);
    }
    
    function calculateMedian(uint256[] memory values) 
        internal 
        pure 
        returns (uint256) 
    {
        // ÂÜíÊ≥°ÊéíÂ∫èÔºàÂÆûÈôÖÂ∫îÁî®‰∏≠Â∫î‰ΩøÁî®Êõ¥È´òÊïàÁöÑÊéíÂ∫èÁÆóÊ≥ïÔºâ
        for (uint i = 0; i < values.length - 1; i++) {
            for (uint j = 0; j < values.length - i - 1; j++) {
                if (values[j] > values[j + 1]) {
                    uint256 temp = values[j];
                    values[j] = values[j + 1];
                    values[j + 1] = temp;
                }
            }
        }
        
        uint256 middle = values.length / 2;
        if (values.length % 2 == 0) {
            return (values[middle - 1] + values[middle]) / 2;
        } else {
            return values[middle];
        }
    }
}
```

### 2. ÊåâÊï∞ÊçÆÁ±ªÂûãÂàÜÁ±ª

#### ‰ª∑Ê†ºÈ¢ÑË®ÄÊú∫
```solidity
contract PriceOracle {
    struct PriceFeed {
        uint256 price;           // ‰ª∑Ê†ºÔºà‰ª•USDËÆ°‰ª∑Ôºå18‰ΩçÂ∞èÊï∞Ôºâ
        uint256 timestamp;       // Êõ¥Êñ∞Êó∂Èó¥
        uint256 roundId;         // ËΩÆÊ¨°ID
        int256 changePercent;    // ÂèòÂåñÁôæÂàÜÊØî
    }
    
    mapping(string => PriceFeed) public priceFeeds;
    mapping(string => uint256[]) public priceHistory;  // ‰ª∑Ê†ºÂéÜÂè≤
    
    uint256 public constant PRICE_DECIMALS = 18;
    uint256 public constant MAX_DELAY = 3600; // 1Â∞èÊó∂
    
    function updatePrice(
        string memory symbol,
        uint256 price,
        uint256 roundId
    ) external onlyAuthorized {
        PriceFeed storage feed = priceFeeds[symbol];
        
        // ËÆ°ÁÆó‰ª∑Ê†ºÂèòÂåñ
        int256 changePercent = 0;
        if (feed.price > 0) {
            changePercent = int256((price * 10000) / feed.price) - 10000;
        }
        
        // Êõ¥Êñ∞‰ª∑Ê†ºÊï∞ÊçÆ
        feed.price = price;
        feed.timestamp = block.timestamp;
        feed.roundId = roundId;
        feed.changePercent = changePercent;
        
        // ‰øùÂ≠òÂéÜÂè≤Êï∞ÊçÆ
        priceHistory[symbol].push(price);
        
        emit PriceUpdated(symbol, price, roundId, changePercent);
    }
    
    function getLatestPrice(string memory symbol) 
        external 
        view 
        returns (uint256 price, uint256 timestamp) 
    {
        PriceFeed memory feed = priceFeeds[symbol];
        require(feed.timestamp > 0, "Price not available");
        require(block.timestamp - feed.timestamp <= MAX_DELAY, "Price stale");
        
        return (feed.price, feed.timestamp);
    }
    
    // Ëé∑ÂèñÂéÜÂè≤‰ª∑Ê†ºTWAP
    function getTWAP(string memory symbol, uint256 period) 
        external 
        view 
        returns (uint256) 
    {
        uint256[] memory history = priceHistory[symbol];
        require(history.length > 0, "No price history");
        
        uint256 sum = 0;
        uint256 count = 0;
        uint256 startIndex = history.length > period ? history.length - period : 0;
        
        for (uint i = startIndex; i < history.length; i++) {
            sum += history[i];
            count++;
        }
        
        return count > 0 ? sum / count : 0;
    }
}
```

#### ÈöèÊú∫Êï∞È¢ÑË®ÄÊú∫
```solidity
contract RandomnessOracle {
    using SafeMath for uint256;
    
    struct RandomRequest {
        uint256 seed;
        address requester;
        bool fulfilled;
        uint256 randomResult;
        uint256 blockNumber;
    }
    
    mapping(uint256 => RandomRequest) public requests;
    uint256 public requestCounter;
    
    // VRFÂØÜÈí•
    mapping(address => bytes32) public vrfKeys;
    
    // ËØ∑Ê±ÇÈöèÊú∫Êï∞
    function requestRandomness(uint256 seed) external payable returns (uint256) {
        require(msg.value >= 0.01 ether, "Insufficient fee");
        
        uint256 requestId = requestCounter++;
        requests[requestId] = RandomRequest({
            seed: seed,
            requester: msg.sender,
            fulfilled: false,
            randomResult: 0,
            blockNumber: block.number
        });
        
        emit RandomnessRequested(requestId, msg.sender, seed);
        return requestId;
    }
    
    // Êèê‰æõÈöèÊú∫Êï∞ÔºàVRFÈ™åËØÅÔºâ
    function fulfillRandomness(
        uint256 requestId,
        uint256 randomness,
        bytes memory proof
    ) external {
        RandomRequest storage request = requests[requestId];
        require(!request.fulfilled, "Already fulfilled");
        require(request.blockNumber < block.number, "Too early");
        
        // È™åËØÅVRFËØÅÊòé
        require(verifyVRFProof(request.seed, randomness, proof), "Invalid proof");
        
        request.randomResult = randomness;
        request.fulfilled = true;
        
        // ÂõûË∞ÉËØ∑Ê±ÇËÄÖ
        IRandomnessConsumer(request.requester).fulfillRandomness(requestId, randomness);
        
        emit RandomnessFulfilled(requestId, randomness);
    }
    
    function verifyVRFProof(
        uint256 seed,
        uint256 randomness,
        bytes memory proof
    ) internal pure returns (bool) {
        // VRFËØÅÊòéÈ™åËØÅÈÄªËæë
        // ÁÆÄÂåñÂÆûÁé∞ÔºåÂÆûÈôÖÈúÄË¶ÅÊ§≠ÂúÜÊõ≤Á∫øÈ™åËØÅ
        return true;
    }
    
    event RandomnessRequested(uint256 indexed requestId, address requester, uint256 seed);
    event RandomnessFulfilled(uint256 indexed requestId, uint256 randomness);
}

interface IRandomnessConsumer {
    function fulfillRandomness(uint256 requestId, uint256 randomness) external;
}
```

#### ‰∫ã‰ª∂È¢ÑË®ÄÊú∫
```solidity
contract EventOracle {
    enum EventStatus { Pending, Resolved, Disputed, Cancelled }
    
    struct Event {
        string description;
        uint256 deadline;
        EventStatus status;
        bytes32 outcome;
        address[] reporters;
        mapping(address => bytes32) reports;
        mapping(bytes32 => uint256) votes;
        uint256 totalReports;
    }
    
    mapping(uint256 => Event) public events;
    uint256 public eventCounter;
    
    mapping(address => uint256) public reporterStakes;
    uint256 public constant MIN_STAKE = 1 ether;
    uint256 public constant DISPUTE_PERIOD = 24 hours;
    
    // ÂàõÂª∫‰∫ã‰ª∂
    function createEvent(
        string memory description,
        uint256 deadline
    ) external returns (uint256) {
        uint256 eventId = eventCounter++;
        Event storage newEvent = events[eventId];
        newEvent.description = description;
        newEvent.deadline = deadline;
        newEvent.status = EventStatus.Pending;
        
        emit EventCreated(eventId, description, deadline);
        return eventId;
    }
    
    // Êä•Âëä‰∫ã‰ª∂ÁªìÊûú
    function reportOutcome(uint256 eventId, bytes32 outcome) external {
        Event storage eventData = events[eventId];
        require(block.timestamp >= eventData.deadline, "Event not ended");
        require(eventData.status == EventStatus.Pending, "Event not pending");
        require(reporterStakes[msg.sender] >= MIN_STAKE, "Insufficient stake");
        require(eventData.reports[msg.sender] == bytes32(0), "Already reported");
        
        // Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¨°Êä•ÂëäÔºåÂ∞ÜÊä•ÂëäËÄÖÂä†ÂÖ•ÂàóË°®
        if (eventData.reports[msg.sender] == bytes32(0)) {
            eventData.reporters.push(msg.sender);
        }
        
        eventData.reports[msg.sender] = outcome;
        eventData.votes[outcome]++;
        eventData.totalReports++;
        
        emit OutcomeReported(eventId, msg.sender, outcome);
        
        // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Ëß£ÂÜ≥‰∫ã‰ª∂
        checkEventResolution(eventId);
    }
    
    function checkEventResolution(uint256 eventId) internal {
        Event storage eventData = events[eventId];
        
        // Â¶ÇÊûúÊúâË∂ÖËøá‰∏ÄÂçäÁöÑÊä•ÂëäËÄÖËææÊàêÂÖ±ËØÜ
        if (eventData.totalReports >= 3) {
            bytes32 winningOutcome = findMajorityOutcome(eventId);
            
            if (eventData.votes[winningOutcome] * 2 > eventData.totalReports) {
                eventData.outcome = winningOutcome;
                eventData.status = EventStatus.Resolved;
                
                emit EventResolved(eventId, winningOutcome);
                
                // Â•ñÂä±Ê≠£Á°ÆÁöÑÊä•ÂëäËÄÖ
                rewardReporters(eventId, winningOutcome);
            }
        }
    }
    
    function findMajorityOutcome(uint256 eventId) 
        internal 
        view 
        returns (bytes32) 
    {
        Event storage eventData = events[eventId];
        bytes32 majority = bytes32(0);
        uint256 maxVotes = 0;
        
        for (uint i = 0; i < eventData.reporters.length; i++) {
            bytes32 outcome = eventData.reports[eventData.reporters[i]];
            if (eventData.votes[outcome] > maxVotes) {
                maxVotes = eventData.votes[outcome];
                majority = outcome;
            }
        }
        
        return majority;
    }
    
    function rewardReporters(uint256 eventId, bytes32 correctOutcome) internal {
        Event storage eventData = events[eventId];
        uint256 totalReward = address(this).balance / 10; // 10%ÁöÑÂ•ñÂä±Ê±†
        uint256 correctReporters = eventData.votes[correctOutcome];
        uint256 rewardPerReporter = totalReward / correctReporters;
        
        for (uint i = 0; i < eventData.reporters.length; i++) {
            address reporter = eventData.reporters[i];
            if (eventData.reports[reporter] == correctOutcome) {
                payable(reporter).transfer(rewardPerReporter);
            }
        }
    }
    
    event EventCreated(uint256 indexed eventId, string description, uint256 deadline);
    event OutcomeReported(uint256 indexed eventId, address reporter, bytes32 outcome);
    event EventResolved(uint256 indexed eventId, bytes32 outcome);
}
```



## È¢ÑË®ÄÊú∫ÈóÆÈ¢òËØ¶Ëß£

### 1. Oracle ProblemÔºàÈ¢ÑË®ÄÊú∫ÈóÆÈ¢òÔºâ

**ÈóÆÈ¢òÊ†∏ÂøÉ**ÔºöÂ¶Ç‰ΩïÁ°Æ‰øùÂ§ñÈÉ®Êï∞ÊçÆÂú®‰º†ÂÖ•Âå∫ÂùóÈìæÊó∂‰øùÊåÅÁúüÂÆûÊÄßÂíåÂèØ‰ø°Â∫¶Ôºü

```
È¢ÑË®ÄÊú∫ÈóÆÈ¢òÁöÑÂ±ÇÈù¢Ôºö

Êï∞ÊçÆËé∑ÂèñÂ±ÇÈù¢Ôºö
‚îú‚îÄ‚îÄ Êï∞ÊçÆÊ∫êÂèØÈù†ÊÄß
‚îú‚îÄ‚îÄ Êï∞ÊçÆ‰º†ËæìÂÆåÊï¥ÊÄß
‚îú‚îÄ‚îÄ Êï∞ÊçÆÊó∂ÊïàÊÄß
‚îî‚îÄ‚îÄ Êï∞ÊçÆÊ†ºÂºèÊ†áÂáÜÂåñ

ÂÖ±ËØÜÂ±ÇÈù¢Ôºö
‚îú‚îÄ‚îÄ Â§öÊï∞ÊçÆÊ∫êËÅöÂêà
‚îú‚îÄ‚îÄ ÂºÇÂ∏∏ÂÄºÂ§ÑÁêÜ
‚îú‚îÄ‚îÄ ÊùÉÈáçÂàÜÈÖçÊú∫Âà∂
‚îî‚îÄ‚îÄ ‰∫âËÆÆËß£ÂÜ≥Êú∫Âà∂

ÊøÄÂä±Â±ÇÈù¢Ôºö
‚îú‚îÄ‚îÄ Êä•ÂëäËÄÖÊøÄÂä±
‚îú‚îÄ‚îÄ ‰ΩúÊÅ∂ÊàêÊú¨ËÆæËÆ°
‚îú‚îÄ‚îÄ ÈïøÊúüÂèÇ‰∏éÂä®Êú∫
‚îî‚îÄ‚îÄ ÁªèÊµéÂÆâÂÖ®ÊÄß
```

### 2. Êï∞ÊçÆÊìçÁ∫µÊîªÂáª

```solidity
// ‰ª∑Ê†ºÊìçÁ∫µÊîªÂáªÁ§∫‰æã
contract VulnerableContract {
    IPriceOracle public priceOracle;
    
    function liquidate(address user) external {
        // Âç±Èô©ÔºöÁõ¥Êé•‰ΩøÁî®Âçï‰∏ÄÈ¢ÑË®ÄÊú∫‰ª∑Ê†º
        uint256 collateralPrice = priceOracle.getPrice("ETH");
        uint256 collateralValue = collateralPrice * users[user].collateral;
        
        if (collateralValue < users[user].debt * 150 / 100) {
            // Ê∏ÖÁÆóÈÄªËæë
            _liquidate(user);
        }
    }
}

// ÊîªÂáªËÄÖÂêàÁ∫¶
contract OracleManipulator {
    IFlashLoan public flashLoan;
    VulnerableContract public target;
    
    function attack() external {
        // 1. ÈÄöËøáÈó™ÁîµË¥∑Ëé∑ÂæóÂ§ßÈáèËµÑÈáë
        flashLoan.flashLoan(1000 ether, address(this));
    }
    
    function executeFlashLoan(uint256 amount) external {
        // 2. ÊìçÁ∫µ‰ª∑Ê†º
        manipulatePrice();
        
        // 3. ÊâßË°åÊúâÂà©ÁöÑÊìç‰Ωú
        target.liquidate(targetUser);
        
        // 4. ËøòÂéü‰ª∑Ê†ºÂπ∂ÂÅøËøòÈó™ÁîµË¥∑
        restorePrice();
        flashLoan.repay(amount);
    }
}

// Èò≤Êä§Êé™ÊñΩ
contract SecureContract {
    IPriceOracle[] public priceOracles;
    
    function getSecurePrice(string memory symbol) internal view returns (uint256) {
        uint256[] memory prices = new uint256[](priceOracles.length);
        
        // ‰ªéÂ§ö‰∏™È¢ÑË®ÄÊú∫Ëé∑Âèñ‰ª∑Ê†º
        for (uint i = 0; i < priceOracles.length; i++) {
            prices[i] = priceOracles[i].getPrice(symbol);
        }
        
        // ‰ΩøÁî®‰∏≠‰ΩçÊï∞‰Ωú‰∏∫ÊúÄÁªà‰ª∑Ê†º
        return calculateMedian(prices);
    }
    
    function liquidate(address user) external {
        uint256 currentPrice = getSecurePrice("ETH");
        uint256 previousPrice = getPreviousPrice("ETH", 1 hours);
        
        // Ê£ÄÊü•‰ª∑Ê†ºÂèòÂåñÊòØÂê¶Ëøá‰∫éÂâßÁÉà
        require(
            abs(int256(currentPrice) - int256(previousPrice)) * 100 / int256(previousPrice) < 10,
            "Price change too drastic"
        );
        
        // ‰ΩøÁî®TWAP‰ª∑Ê†ºËøõË°åÊ∏ÖÁÆó
        uint256 twapPrice = getTWAPPrice("ETH", 4 hours);
        uint256 collateralValue = twapPrice * users[user].collateral;
        
        if (collateralValue < users[user].debt * 150 / 100) {
            _liquidate(user);
        }
    }
}
```

### 3. ÂâçÁΩÆ‰∫§ÊòìÊîªÂáª

```solidity
contract FrontRunningResistantOracle {
    struct PriceSubmission {
        bytes32 commitment;    // ÊâøËØ∫ÂÄº
        uint256 revealDeadline;
        bool revealed;
        uint256 price;
    }
    
    mapping(address => mapping(string => PriceSubmission)) public submissions;
    
    uint256 public constant COMMIT_DURATION = 10 minutes;
    uint256 public constant REVEAL_DURATION = 5 minutes;
    
    // Á¨¨‰∏ÄÈò∂ÊÆµÔºöÊèê‰∫§ÊâøËØ∫
    function commitPrice(string memory symbol, bytes32 commitment) external {
        require(authorizedOracles[msg.sender], "Not authorized");
        
        submissions[msg.sender][symbol] = PriceSubmission({
            commitment: commitment,
            revealDeadline: block.timestamp + COMMIT_DURATION + REVEAL_DURATION,
            revealed: false,
            price: 0
        });
        
        emit PriceCommitted(msg.sender, symbol, commitment);
    }
    
    // Á¨¨‰∫åÈò∂ÊÆµÔºöÊè≠Á§∫‰ª∑Ê†º
    function revealPrice(
        string memory symbol,
        uint256 price,
        uint256 nonce
    ) external {
        PriceSubmission storage submission = submissions[msg.sender][symbol];
        
        require(submission.commitment != bytes32(0), "No commitment");
        require(!submission.revealed, "Already revealed");
        require(block.timestamp >= submission.revealDeadline - REVEAL_DURATION, "Reveal period not started");
        require(block.timestamp <= submission.revealDeadline, "Reveal period ended");
        
        // È™åËØÅÊâøËØ∫
        bytes32 hash = keccak256(abi.encodePacked(price, nonce, msg.sender));
        require(hash == submission.commitment, "Invalid reveal");
        
        submission.revealed = true;
        submission.price = price;
        
        emit PriceRevealed(msg.sender, symbol, price);
        
        // Â∞ùËØïËÅöÂêà‰ª∑Ê†º
        tryAggregatePrice(symbol);
    }
    
    function tryAggregatePrice(string memory symbol) internal {
        // Êî∂ÈõÜÊâÄÊúâÂ∑≤Êè≠Á§∫ÁöÑ‰ª∑Ê†º
        uint256[] memory prices = new uint256[](authorizedOraclesList.length);
        uint256 revealedCount = 0;
        
        for (uint i = 0; i < authorizedOraclesList.length; i++) {
            PriceSubmission storage sub = submissions[authorizedOraclesList[i]][symbol];
            if (sub.revealed) {
                prices[revealedCount] = sub.price;
                revealedCount++;
            }
        }
        
        // Â¶ÇÊûúËææÂà∞ÊúÄÂ∞èÊè≠Á§∫Êï∞ÈáèÔºåËøõË°åËÅöÂêà
        if (revealedCount >= minReveals) {
            uint256 aggregatedPrice = calculateMedian(prices, revealedCount);
            updateAggregatedPrice(symbol, aggregatedPrice);
        }
    }
}
```



## ‰∏ªÊµÅÈ¢ÑË®ÄÊú∫È°πÁõÆ

### 1. ChainlinkËØ¶Ëß£

```solidity
// Chainlink‰ª∑Ê†ºÈ¢ÑË®ÄÊú∫ÈõÜÊàê
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract ChainlinkPriceConsumer {
    AggregatorV3Interface internal priceFeed;
    
    constructor() {
        // ETH/USD ‰ª∑Ê†ºÈ¢ÑË®ÄÊú∫Âú∞ÂùÄ (Ethereum Mainnet)
        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
    }
    
    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID, 
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        
        return price;
    }
    
    function getHistoricalPrice(uint80 _roundId) public view returns (int) {
        (
            uint80 roundID, 
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.getRoundData(_roundId);
        
        return price;
    }
    
    function getPriceDecimals() public view returns (uint8) {
        return priceFeed.decimals();
    }
}

// Chainlink VRFÈöèÊú∫Êï∞
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract RandomNumberConsumer is VRFConsumerBase {
    bytes32 internal keyHash;
    uint256 internal fee;
    uint256 public randomResult;
    
    constructor() VRFConsumerBase(
        0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655C, // VRF Coordinator
        0x01BE23585060835E02B77ef475b0Cc51aA1e0709  // LINK Token
    ) {
        keyHash = 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311;
        fee = 0.1 * 10 ** 18; // 0.1 LINK
    }
    
    function getRandomNumber() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
        return requestRandomness(keyHash, fee);
    }
    
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResult = randomness;
    }
}

// Chainlink‰ªª‰ΩïAPIË∞ÉÁî®
import "@chainlink/contracts/src/v0.8/ChainlinkClient.sol";

contract APIConsumer is ChainlinkClient {
    using Chainlink for Chainlink.Request;
    
    uint256 public volume;
    address private oracle;
    bytes32 private jobId;
    uint256 private fee;
    
    constructor() {
        setPublicChainlinkToken();
        oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
        jobId = "d5270d1c311941d0b08bead21fea7747";
        fee = 0.1 * 10 ** 18; // 0.1 LINK
    }
    
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
        
        request.add("get", "https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD");
        request.add("path", "RAW.ETH.USD.VOLUME24HOUR");
        
        int timesAmount = 10**18;
        request.addInt("times", timesAmount);
        
        return sendChainlinkRequestTo(oracle, request, fee);
    }
    
    function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
        volume = _volume;
    }
}
```

### 2. Band ProtocolÂÆûÁé∞

```solidity
// Band ProtocolÈõÜÊàê
interface IStdReference {
    struct ReferenceData {
        uint256 rate;
        uint256 lastUpdatedBase;
        uint256 lastUpdatedQuote;
    }
    
    function getReferenceData(string memory _base, string memory _quote) 
        external 
        view 
        returns (ReferenceData memory);
    
    function getReferenceDatas(string[] memory _bases, string[] memory _quotes) 
        external 
        view 
        returns (ReferenceData[] memory);
}

contract BandPriceConsumer {
    IStdReference internal ref;
    
    constructor(IStdReference _ref) {
        ref = _ref;
    }
    
    function getPrice(string memory base, string memory quote) 
        external 
        view 
        returns (uint256) 
    {
        IStdReference.ReferenceData memory data = ref.getReferenceData(base, quote);
        return data.rate;
    }
    
    function getMultiplePrices(
        string[] memory bases,
        string[] memory quotes
    ) external view returns (uint256[] memory) {
        require(bases.length == quotes.length, "BAD_INPUT_LENGTH");
        
        uint256[] memory prices = new uint256[](bases.length);
        IStdReference.ReferenceData[] memory data = ref.getReferenceDatas(bases, quotes);
        
        for (uint256 i = 0; i < bases.length; i++) {
            prices[i] = data[i].rate;
        }
        
        return prices;
    }
}
```

### 3. Uniswap V3‰Ωú‰∏∫È¢ÑË®ÄÊú∫

```solidity
// Uniswap V3 TWAPÈ¢ÑË®ÄÊú∫
import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';

contract UniswapV3Oracle {
    address public immutable pool;
    address public immutable token0;
    address public immutable token1;
    
    constructor(address _pool) {
        pool = _pool;
        token0 = IUniswapV3Pool(_pool).token0();
        token1 = IUniswapV3Pool(_pool).token1();
    }
    
    function getTWAP(uint32 twapInterval) public view returns (int24) {
        if (twapInterval == 0) {
            // Ëé∑ÂèñÂΩìÂâçtick
            (, int24 tick,,,,,) = IUniswapV3Pool(pool).slot0();
            return tick;
        } else {
            uint32[] memory secondsAgos = new uint32[](2);
            secondsAgos[0] = twapInterval;
            secondsAgos[1] = 0;
            
            (int56[] memory tickCumulatives,) = IUniswapV3Pool(pool).observe(secondsAgos);
            
            // ËÆ°ÁÆóÊó∂Èó¥Âä†ÊùÉÂπ≥Âùátick
            return int24((tickCumulatives[1] - tickCumulatives[0]) / twapInterval);
        }
    }
    
    function getPrice(uint32 twapInterval) external view returns (uint256) {
        int24 tick = getTWAP(twapInterval);
        
        // Â∞ÜtickËΩ¨Êç¢‰∏∫‰ª∑Ê†º
        return OracleLibrary.getQuoteAtTick(
            tick,
            uint128(10 ** IERC20Metadata(token0).decimals()),
            token0,
            token1
        );
    }
    
    function checkDataAge() external view returns (uint256) {
        uint32 oldestObservation = OracleLibrary.getOldestObservationSecondsAgo(pool);
        return oldestObservation;
    }
}
```



## È¢ÑË®ÄÊú∫ÊîªÂáª‰∏éÂÆâÂÖ®

### 1. Èó™ÁîµË¥∑ÊîªÂáªÊ°à‰æãÂàÜÊûê

```solidity
// ÂÆπÊòìÂèóÊîªÂáªÁöÑÂÄüË¥∑ÂçèËÆÆ
contract VulnerableLendingProtocol {
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrows;
    
    IPriceOracle public priceOracle;
    
    function borrow(address token, uint256 amount) external {
        uint256 collateralValue = getCollateralValue(msg.sender);
        uint256 borrowValue = priceOracle.getPrice(token) * amount / 1e18;
        
        require(collateralValue * 150 / 100 >= borrowValue, "Insufficient collateral");
        
        borrows[msg.sender] += borrowValue;
        IERC20(token).transfer(msg.sender, amount);
    }
    
    function getCollateralValue(address user) internal view returns (uint256) {
        // ÁÆÄÂåñÔºöÂÅáËÆæÊäµÊäºÂìÅ‰∏∫ETH
        return priceOracle.getPrice("ETH") * deposits[user] / 1e18;
    }
}

// ÊîªÂáªËÄÖÂêàÁ∫¶
contract FlashLoanAttacker {
    IFlashLoan flashLoan;
    VulnerableLendingProtocol target;
    IUniswapV2Router router;
    
    function executeAttack() external {
        // 1. ÈÄöËøáÈó™ÁîµË¥∑ÂÄüÂÖ•Â§ßÈáèETH
        flashLoan.flashLoan(1000 ether);
    }
    
    function onFlashLoan(uint256 amount) external {
        // 2. Âú®DEX‰∏äÂ§ßÈáèÂçñÂá∫ETHÔºåÂéã‰Ωé‰ª∑Ê†º
        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = USDC;
        
        router.swapExactTokensForTokens(
            800 ether,
            0,
            path,
            address(this),
            block.timestamp + 300
        );
        
        // 3. Ê≠§Êó∂ETH‰ª∑Ê†ºË¢´Âéã‰ΩéÔºåÂèØ‰ª•ÂÄüÂá∫Êõ¥Â§öËµÑ‰∫ß
        target.borrow(USDC, calculateMaxBorrow());
        
        // 4. ‰π∞ÂõûETHÔºåÊÅ¢Â§ç‰ª∑Ê†º
        path[0] = USDC;
        path[1] = WETH;
        
        router.swapTokensForExactTokens(
            800 ether,
            IERC20(USDC).balanceOf(address(this)),
            path,
            address(this),
            block.timestamp + 300
        );
        
        // 5. ÂΩíËøòÈó™ÁîµË¥∑
        IERC20(WETH).transfer(address(flashLoan), amount);
        
        // 6. Ëé∑Âà©ÈÄÄÂá∫
        // ÊîªÂáªËÄÖÁé∞Âú®Êã•Êúâ‰∫ÜÈ¢ùÂ§ñÂÄüÂá∫ÁöÑUSDC
    }
}
```

### 2. ÂÆâÂÖ®Èò≤Êä§Êé™ÊñΩ

```solidity
contract SecureLendingProtocol {
    using SafeMath for uint256;
    
    // Â§öÈ¢ÑË®ÄÊú∫ËÅöÂêà
    struct PriceData {
        uint256 chainlinkPrice;
        uint256 bandPrice;
        uint256 uniswapTWAP;
        uint256 aggregatedPrice;
        uint256 lastUpdate;
    }
    
    mapping(string => PriceData) public priceData;
    
    // È¢ÑË®ÄÊú∫Âú∞ÂùÄ
    AggregatorV3Interface public chainlinkOracle;
    IStdReference public bandOracle;
    UniswapV3Oracle public uniswapOracle;
    
    // ÂÆâÂÖ®ÂèÇÊï∞
    uint256 public constant MAX_PRICE_DEVIATION = 500; // 5%
    uint256 public constant TWAP_PERIOD = 30 minutes;
    uint256 public constant PRICE_STALENESS_THRESHOLD = 1 hours;
    
    function updatePrices(string memory symbol) external {
        PriceData storage data = priceData[symbol];
        
        // ‰ªéÂ§ö‰∏™È¢ÑË®ÄÊú∫Ëé∑Âèñ‰ª∑Ê†º
        data.chainlinkPrice = getChainlinkPrice(symbol);
        data.bandPrice = getBandPrice(symbol);
        data.uniswapTWAP = getUniswapTWAP(symbol);
        
        // È™åËØÅ‰ª∑Ê†ºÂÅèÂ∑Æ
        require(validatePriceDeviation(data), "Price deviation too high");
        
        // ËÅöÂêà‰ª∑Ê†ºÔºà‰ΩøÁî®‰∏≠‰ΩçÊï∞Ôºâ
        uint256[] memory prices = new uint256[](3);
        prices[0] = data.chainlinkPrice;
        prices[1] = data.bandPrice;
        prices[2] = data.uniswapTWAP;
        
        data.aggregatedPrice = calculateMedian(prices);
        data.lastUpdate = block.timestamp;
        
        emit PriceUpdated(symbol, data.aggregatedPrice);
    }
    
    function validatePriceDeviation(PriceData memory data) 
        internal 
        pure 
        returns (bool) 
    {
        uint256[] memory prices = new uint256[](3);
        prices[0] = data.chainlinkPrice;
        prices[1] = data.bandPrice;
        prices[2] = data.uniswapTWAP;
        
        uint256 median = calculateMedian(prices);
        
        // Ê£ÄÊü•ÊØè‰∏™‰ª∑Ê†º‰∏é‰∏≠‰ΩçÊï∞ÁöÑÂÅèÂ∑Æ
        for (uint i = 0; i < prices.length; i++) {
            uint256 deviation = prices[i] > median ?
                (prices[i] - median) * 10000 / median :
                (median - prices[i]) * 10000 / median;
                
            if (deviation > MAX_PRICE_DEVIATION) {
                return false;
            }
        }
        
        return true;
    }
    
    function getSecurePrice(string memory symbol) 
        external 
        view 
        returns (uint256) 
    {
        PriceData memory data = priceData[symbol];
        
        // Ê£ÄÊü•‰ª∑Ê†ºÊñ∞È≤úÂ∫¶
        require(
            block.timestamp - data.lastUpdate <= PRICE_STALENESS_THRESHOLD,
            "Price data stale"
        );
        
        return data.aggregatedPrice;
    }
    
    // Â∏¶ÊúâÊó∂Èó¥Âª∂ËøüÁöÑÂÄüË¥∑ÂáΩÊï∞
    struct BorrowRequest {
        address borrower;
        address token;
        uint256 amount;
        uint256 requestTime;
        bool executed;
    }
    
    mapping(uint256 => BorrowRequest) public borrowRequests;
    uint256 public requestCounter;
    uint256 public constant BORROW_DELAY = 15 minutes;
    
    function requestBorrow(address token, uint256 amount) external returns (uint256) {
        uint256 requestId = requestCounter++;
        
        borrowRequests[requestId] = BorrowRequest({
            borrower: msg.sender,
            token: token,
            amount: amount,
            requestTime: block.timestamp,
            executed: false
        });
        
        emit BorrowRequested(requestId, msg.sender, token, amount);
        return requestId;
    }
    
    function executeBorrow(uint256 requestId) external {
        BorrowRequest storage request = borrowRequests[requestId];
        
        require(!request.executed, "Already executed");
        require(msg.sender == request.borrower, "Not your request");
        require(
            block.timestamp >= request.requestTime + BORROW_DELAY,
            "Delay period not passed"
        );
        
        // Âú®Âª∂ËøüÊúüÂêéÈáçÊñ∞Ê£ÄÊü•ÊäµÊäºÂìÅ‰ª∑ÂÄº
        uint256 collateralValue = getCollateralValue(request.borrower);
        string memory tokenSymbol = getTokenSymbol(request.token);
        uint256 borrowValue = getSecurePrice(tokenSymbol) * request.amount / 1e18;
        
        require(collateralValue * 150 / 100 >= borrowValue, "Insufficient collateral");
        
        request.executed = true;
        IERC20(request.token).transfer(request.borrower, request.amount);
        
        emit BorrowExecuted(requestId);
    }
}
```

### 3. È¢ÑË®ÄÊú∫ÊïÖÈöúÂ∫îÊÄ•Êú∫Âà∂

```solidity
contract OracleFailsafe {
    enum EmergencyState { Normal, Degraded, Emergency, Shutdown }
    
    EmergencyState public currentState = EmergencyState.Normal;
    address public emergencyAdmin;
    
    // Â∫îÊÄ•‰ª∑Ê†ºÊï∞ÊçÆ
    mapping(string => uint256) public emergencyPrices;
    mapping(string => uint256) public emergencyPriceTimestamps;
    
    // È¢ÑË®ÄÊú∫ÂÅ•Â∫∑Áä∂ÊÄÅÁõëÊéß
    struct OracleHealth {
        uint256 lastUpdate;
        uint256 consecutiveFailures;
        bool isActive;
    }
    
    mapping(address => OracleHealth) public oracleHealth;
    address[] public oracleList;
    
    uint256 public constant MAX_FAILURES = 3;
    uint256 public constant EMERGENCY_PRICE_VALIDITY = 24 hours;
    
    modifier onlyEmergencyAdmin() {
        require(msg.sender == emergencyAdmin, "Not emergency admin");
        _;
    }
    
    modifier notInEmergency() {
        require(currentState != EmergencyState.Shutdown, "System in emergency");
        _;
    }
    
    function checkOracleHealth() external {
        uint256 activeOracles = 0;
        uint256 failedOracles = 0;
        
        for (uint i = 0; i < oracleList.length; i++) {
            address oracle = oracleList[i];
            OracleHealth storage health = oracleHealth[oracle];
            
            // Ê£ÄÊü•È¢ÑË®ÄÊú∫ÊòØÂê¶ÂèäÊó∂Êõ¥Êñ∞
            if (block.timestamp - health.lastUpdate > 2 hours) {
                health.consecutiveFailures++;
                
                if (health.consecutiveFailures >= MAX_FAILURES) {
                    health.isActive = false;
                    failedOracles++;
                }
            } else {
                health.consecutiveFailures = 0;
                health.isActive = true;
                activeOracles++;
            }
        }
        
        // Ê†πÊçÆÊ¥ªË∑ÉÈ¢ÑË®ÄÊú∫Êï∞ÈáèË∞ÉÊï¥Á≥ªÁªüÁä∂ÊÄÅ
        updateSystemState(activeOracles, failedOracles);
    }
    
    function updateSystemState(uint256 active, uint256 failed) internal {
        uint256 totalOracles = oracleList.length;
        
        if (active == 0) {
            currentState = EmergencyState.Shutdown;
        } else if (active < totalOracles / 2) {
            currentState = EmergencyState.Emergency;
        } else if (failed > 0) {
            currentState = EmergencyState.Degraded;
        } else {
            currentState = EmergencyState.Normal;
        }
        
        emit SystemStateChanged(currentState);
    }
    
    // Â∫îÊÄ•‰ª∑Ê†ºËÆæÁΩÆ
    function setEmergencyPrice(string memory symbol, uint256 price) 
        external 
        onlyEmergencyAdmin 
    {
        require(
            currentState == EmergencyState.Emergency || 
            currentState == EmergencyState.Shutdown,
            "Not in emergency state"
        );
        
        emergencyPrices[symbol] = price;
        emergencyPriceTimestamps[symbol] = block.timestamp;
        
        emit EmergencyPriceSet(symbol, price);
    }
    
    function getPrice(string memory symbol) external view returns (uint256) {
        if (currentState == EmergencyState.Normal) {
            return getAggregatedPrice(symbol);
        } else if (currentState == EmergencyState.Degraded) {
            return getAggregatedPriceWithFallback(symbol);
        } else {
            // Emergency or Shutdown state
            require(emergencyPrices[symbol] > 0, "No emergency price set");
            require(
                block.timestamp - emergencyPriceTimestamps[symbol] <= EMERGENCY_PRICE_VALIDITY,
                "Emergency price expired"
            );
            return emergencyPrices[symbol];
        }
    }
    
    // Ê∏êËøõÂºèÊÅ¢Â§çÊú∫Âà∂
    function initiateRecovery() external onlyEmergencyAdmin {
        require(currentState != EmergencyState.Normal, "System already normal");
        
        // ÈáçÊñ∞Ê£ÄÊü•ÊâÄÊúâÈ¢ÑË®ÄÊú∫
        for (uint i = 0; i < oracleList.length; i++) {
            oracleHealth[oracleList[i]].consecutiveFailures = 0;
        }
        
        // ÈÄêÊ≠•ÊÅ¢Â§ç
        checkOracleHealth();
        
        emit RecoveryInitiated();
    }
    
    event SystemStateChanged(EmergencyState newState);
    event EmergencyPriceSet(string symbol, uint256 price);
    event RecoveryInitiated();
}
```



## È¢ÑË®ÄÊú∫Êû∂ÊûÑËÆæËÆ°

### 1. ÂàÜÂ±ÇÊû∂ÊûÑËÆæËÆ°

```
È¢ÑË®ÄÊú∫Á≥ªÁªüÊû∂ÊûÑÔºö

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                Â∫îÁî®Â±Ç (Application)                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ   DeFi      ‚îÇ ‚îÇ    ‰øùÈô©     ‚îÇ ‚îÇ   Ë°çÁîüÂìÅ    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   ÂçèËÆÆ      ‚îÇ ‚îÇ    ÂêàÁ∫¶     ‚îÇ ‚îÇ    ‰∫§Êòì     ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              ËÅöÂêàÂ±Ç (Aggregation)                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ  ‰ª∑Ê†ºËÅöÂêà   ‚îÇ ‚îÇ  Êï∞ÊçÆÈ™åËØÅ   ‚îÇ ‚îÇ  ÂÖ±ËØÜÊú∫Âà∂   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               ËäÇÁÇπÂ±Ç (Oracle Nodes)                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ   ËäÇÁÇπA     ‚îÇ ‚îÇ    ËäÇÁÇπB    ‚îÇ ‚îÇ    ËäÇÁÇπC    ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               Êï∞ÊçÆÊ∫êÂ±Ç (Data Sources)               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ   ‰∫§ÊòìÊâÄ    ‚îÇ ‚îÇ   APIÊúçÂä°   ‚îÇ ‚îÇ   IoTËÆæÂ§á   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2. ÂÆåÊï¥ÁöÑÈ¢ÑË®ÄÊú∫Á≥ªÁªüÂÆûÁé∞

```solidity
// È¢ÑË®ÄÊú∫Á≥ªÁªü‰∏ªÂêàÁ∫¶
contract OracleSystem {
    using SafeMath for uint256;
    
    // Á≥ªÁªüËßíËâ≤
    mapping(address => bool) public oracleNodes;
    mapping(address => bool) public dataConsumers;
    address public admin;
    
    // Êï∞ÊçÆÁªìÊûÑ
    struct DataFeed {
        string feedId;
        uint8 decimals;
        uint256 deviation; // ÂÖÅËÆ∏ÁöÑÊúÄÂ§ßÂÅèÂ∑Æ
        uint256 heartbeat; // Êï∞ÊçÆÊõ¥Êñ∞ÂøÉË∑≥Èó¥Èöî
        uint256 minAnswers;
        uint256 maxAnswers;
        address[] oracles;
        bool active;
    }
    
    struct Submission {
        uint256 value;
        uint256 timestamp;
        address oracle;
    }
    
    struct Round {
        uint256 answer;
        uint256 timestamp;
        uint256 startedAt;
        uint80 roundId;
        uint80 answeredInRound;
    }
    
    // Â≠òÂÇ®ÁªìÊûÑ
    mapping(string => DataFeed) public dataFeeds;
    mapping(string => mapping(uint80 => Round)) public rounds;
    mapping(string => mapping(uint80 => Submission[])) public submissions;
    mapping(string => uint80) public latestRoundId;
    
    // ‰∫ã‰ª∂ÂÆö‰πâ
    event DataFeedCreated(string indexed feedId, address[] oracles);
    event AnswerUpdated(string indexed feedId, int256 current, uint80 roundId, uint256 updatedAt);
    event NewRound(string indexed feedId, uint80 roundId, address startedBy, uint256 startedAt);
    
    constructor() {
        admin = msg.sender;
    }
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin");
        _;
    }
    
    modifier onlyOracle(string memory feedId) {
        require(isOracleAuthorized(feedId, msg.sender), "Not authorized oracle");
        _;
    }
    
    // ÂàõÂª∫Êï∞ÊçÆÊ∫ê
    function createDataFeed(
        string memory feedId,
        uint8 decimals,
        uint256 deviation,
        uint256 heartbeat,
        uint256 minAnswers,
        uint256 maxAnswers,
        address[] memory oracles
    ) external onlyAdmin {
        require(!dataFeeds[feedId].active, "Feed already exists");
        require(oracles.length >= minAnswers, "Not enough oracles");
        require(minAnswers > 0, "Min answers must be > 0");
        require(maxAnswers >= minAnswers, "Max answers must be >= min answers");
        
        dataFeeds[feedId] = DataFeed({
            feedId: feedId,
            decimals: decimals,
            deviation: deviation,
            heartbeat: heartbeat,
            minAnswers: minAnswers,
            maxAnswers: maxAnswers,
            oracles: oracles,
            active: true
        });
        
        // ÊéàÊùÉÈ¢ÑË®ÄÊú∫ËäÇÁÇπ
        for (uint i = 0; i < oracles.length; i++) {
            oracleNodes[oracles[i]] = true;
        }
        
        emit DataFeedCreated(feedId, oracles);
    }
    
    // Êèê‰∫§Êï∞ÊçÆ
    function submit(string memory feedId, uint256 value) 
        external 
        onlyOracle(feedId) 
    {
        DataFeed storage feed = dataFeeds[feedId];
        require(feed.active, "Feed not active");
        
        uint80 currentRoundId = latestRoundId[feedId];
        
        // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂºÄÂßãÊñ∞ËΩÆÊ¨°
        if (shouldStartNewRound(feedId, currentRoundId)) {
            currentRoundId = startNewRound(feedId);
        }
        
        // Ê∑ªÂä†Êèê‰∫§
        submissions[feedId][currentRoundId].push(Submission({
            value: value,
            timestamp: block.timestamp,
            oracle: msg.sender
        }));
        
        // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ËÅöÂêàÁ≠îÊ°à
        if (submissions[feedId][currentRoundId].length >= feed.minAnswers) {
            aggregateAndUpdate(feedId, currentRoundId);
        }
    }
    
    function shouldStartNewRound(string memory feedId, uint80 roundId) 
        internal 
        view 
        returns (bool) 
    {
        if (roundId == 0) return true;
        
        Round storage round = rounds[feedId][roundId];
        DataFeed storage feed = dataFeeds[feedId];
        
        // Ê£ÄÊü•ÂøÉË∑≥Èó¥Èöî
        if (block.timestamp.sub(round.timestamp) >= feed.heartbeat) {
            return true;
        }
        
        // Ê£ÄÊü•ÂÅèÂ∑ÆËß¶Âèë
        if (hasDeviationTriggered(feedId, roundId)) {
            return true;
        }
        
        return false;
    }
    
    function startNewRound(string memory feedId) internal returns (uint80) {
        uint80 newRoundId = latestRoundId[feedId] + 1;
        latestRoundId[feedId] = newRoundId;
        
        rounds[feedId][newRoundId] = Round({
            answer: 0,
            timestamp: 0,
            startedAt: block.timestamp,
            roundId: newRoundId,
            answeredInRound: 0
        });
        
        emit NewRound(feedId, newRoundId, msg.sender, block.timestamp);
        return newRoundId;
    }
    
    function aggregateAndUpdate(string memory feedId, uint80 roundId) internal {
        Submission[] storage subs = submissions[feedId][roundId];
        DataFeed storage feed = dataFeeds[feedId];
        
        // Êî∂ÈõÜÊâÄÊúâÂÄº
        uint256[] memory values = new uint256[](subs.length);
        for (uint i = 0; i < subs.length; i++) {
            values[i] = subs[i].value;
        }
        
        // ËÆ°ÁÆóËÅöÂêàÂÄºÔºà‰ΩøÁî®‰∏≠‰ΩçÊï∞Ôºâ
        uint256 aggregatedValue = calculateMedian(values);
        
        // Êõ¥Êñ∞ËΩÆÊ¨°Êï∞ÊçÆ
        Round storage round = rounds[feedId][roundId];
        round.answer = aggregatedValue;
        round.timestamp = block.timestamp;
        round.answeredInRound = roundId;
        
        emit AnswerUpdated(feedId, int256(aggregatedValue), roundId, block.timestamp);
    }
    
    function calculateMedian(uint256[] memory values) 
        internal 
        pure 
        returns (uint256) 
    {
        // Âø´ÈÄüÊéíÂ∫è
        quickSort(values, 0, values.length - 1);
        
        uint256 middle = values.length / 2;
        if (values.length % 2 == 0) {
            return (values[middle - 1] + values[middle]) / 2;
        } else {
            return values[middle];
        }
    }
    
    function quickSort(uint256[] memory arr, uint256 left, uint256 right) internal pure {
        if (left < right) {
            uint256 pivotIndex = partition(arr, left, right);
            if (pivotIndex > 0) {
                quickSort(arr, left, pivotIndex - 1);
            }
            quickSort(arr, pivotIndex + 1, right);
        }
    }
    
    function partition(uint256[] memory arr, uint256 left, uint256 right) 
        internal 
        pure 
        returns (uint256) 
    {
        uint256 pivot = arr[right];
        uint256 i = left;
        
        for (uint256 j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                (arr[i], arr[j]) = (arr[j], arr[i]);
                i++;
            }
        }
        (arr[i], arr[right]) = (arr[right], arr[i]);
        return i;
    }
    
    // Ëé∑ÂèñÊúÄÊñ∞‰ª∑Ê†º
    function latestAnswer(string memory feedId) external view returns (int256) {
        uint80 roundId = latestRoundId[feedId];
        require(roundId > 0, "No data available");
        return int256(rounds[feedId][roundId].answer);
    }
    
    function latestRoundData(string memory feedId) 
        external 
        view 
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) 
    {
        roundId = latestRoundId[feedId];
        require(roundId > 0, "No data available");
        
        Round storage round = rounds[feedId][roundId];
        return (
            round.roundId,
            int256(round.answer),
            round.startedAt,
            round.timestamp,
            round.answeredInRound
        );
    }
    
    function isOracleAuthorized(string memory feedId, address oracle) 
        public 
        view 
        returns (bool) 
    {
        DataFeed storage feed = dataFeeds[feedId];
        for (uint i = 0; i < feed.oracles.length; i++) {
            if (feed.oracles[i] == oracle) {
                return true;
            }
        }
        return false;
    }
}
```

### 3. ËäÇÁÇπÂÆ¢Êà∑Á´ØÊû∂ÊûÑ

```typescript
// OracleËäÇÁÇπÂÆ¢Êà∑Á´ØÂÆûÁé∞
class OracleNode {
    private wallet: ethers.Wallet;
    private contract: ethers.Contract;
    private dataProviders: Map<string, DataProvider>;
    private feeds: Set<string>;
    
    constructor(
        privateKey: string, 
        contractAddress: string, 
        provider: ethers.providers.Provider
    ) {
        this.wallet = new ethers.Wallet(privateKey, provider);
        this.contract = new ethers.Contract(contractAddress, OracleABI, this.wallet);
        this.dataProviders = new Map();
        this.feeds = new Set();
    }
    
    // Ê∑ªÂä†Êï∞ÊçÆÊèê‰æõÂïÜ
    addDataProvider(feedId: string, provider: DataProvider) {
        this.dataProviders.set(feedId, provider);
        this.feeds.add(feedId);
    }
    
    // ÂêØÂä®ÁõëÂê¨
    async start() {
        console.log(`Oracle node starting with address: ${this.wallet.address}`);
        
        // ÁõëÂê¨Êñ∞ËΩÆÊ¨°‰∫ã‰ª∂
        this.contract.on('NewRound', (feedId, roundId, startedBy, startedAt) => {
            this.handleNewRound(feedId, roundId);
        });
        
        // ÂÆöÊúüÊ£ÄÊü•ÂíåÊèê‰∫§Êï∞ÊçÆ
        setInterval(() => {
            this.checkAndSubmitData();
        }, 30000); // 30ÁßíÈó¥Èöî
    }
    
    // Â§ÑÁêÜÊñ∞ËΩÆÊ¨°
    async handleNewRound(feedId: string, roundId: number) {
        if (!this.feeds.has(feedId)) return;
        
        try {
            console.log(`New round detected: ${feedId}, round ${roundId}`);
            await this.submitDataForFeed(feedId);
        } catch (error) {
            console.error(`Error handling new round for ${feedId}:`, error);
        }
    }
    
    // Ê£ÄÊü•Âπ∂Êèê‰∫§Êï∞ÊçÆ
    async checkAndSubmitData() {
        for (const feedId of this.feeds) {
            try {
                const shouldSubmit = await this.shouldSubmitData(feedId);
                if (shouldSubmit) {
                    await this.submitDataForFeed(feedId);
                }
            } catch (error) {
                console.error(`Error checking feed ${feedId}:`, error);
            }
        }
    }
    
    // Âà§Êñ≠ÊòØÂê¶Â∫îËØ•Êèê‰∫§Êï∞ÊçÆ
    async shouldSubmitData(feedId: string): Promise<boolean> {
        const feed = await this.contract.dataFeeds(feedId);
        const latestRoundId = await this.contract.latestRoundId(feedId);
        
        if (latestRoundId.eq(0)) return true; // È¶ñÊ¨°Êèê‰∫§
        
        const latestRound = await this.contract.rounds(feedId, latestRoundId);
        const timeSinceUpdate = Date.now() / 1000 - latestRound.timestamp.toNumber();
        
        // Ê£ÄÊü•ÂøÉË∑≥Èó¥Èöî
        if (timeSinceUpdate >= feed.heartbeat.toNumber()) {
            return true;
        }
        
        // Ê£ÄÊü•‰ª∑Ê†ºÂÅèÂ∑Æ
        const currentPrice = await this.getCurrentPrice(feedId);
        const deviation = this.calculateDeviation(currentPrice, latestRound.answer.toNumber());
        
        if (deviation >= feed.deviation.toNumber()) {
            return true;
        }
        
        return false;
    }
    
    // Êèê‰∫§Êï∞ÊçÆ
    async submitDataForFeed(feedId: string) {
        try {
            const price = await this.getCurrentPrice(feedId);
            console.log(`Submitting price for ${feedId}: ${price}`);
            
            const tx = await this.contract.submit(feedId, price, {
                gasLimit: 200000
            });
            
            await tx.wait();
            console.log(`Successfully submitted data for ${feedId}`);
        } catch (error) {
            console.error(`Failed to submit data for ${feedId}:`, error);
        }
    }
    
    // Ëé∑ÂèñÂΩìÂâç‰ª∑Ê†º
    async getCurrentPrice(feedId: string): Promise<number> {
        const provider = this.dataProviders.get(feedId);
        if (!provider) {
            throw new Error(`No data provider for ${feedId}`);
        }
        
        return await provider.getPrice();
    }
    
    // ËÆ°ÁÆóÂÅèÂ∑Æ
    calculateDeviation(newPrice: number, oldPrice: number): number {
        if (oldPrice === 0) return 0;
        return Math.abs((newPrice - oldPrice) * 10000 / oldPrice);
    }
}

// Êï∞ÊçÆÊèê‰æõÂïÜÊé•Âè£
interface DataProvider {
    getPrice(): Promise<number>;
}

// ‰∫§ÊòìÊâÄÊï∞ÊçÆÊèê‰æõÂïÜ
class ExchangeDataProvider implements DataProvider {
    private symbol: string;
    private exchanges: string[];
    
    constructor(symbol: string, exchanges: string[]) {
        this.symbol = symbol;
        this.exchanges = exchanges;
    }
    
    async getPrice(): Promise<number> {
        const prices: number[] = [];
        
        // ‰ªéÂ§ö‰∏™‰∫§ÊòìÊâÄËé∑Âèñ‰ª∑Ê†º
        for (const exchange of this.exchanges) {
            try {
                const price = await this.fetchPriceFromExchange(exchange);
                if (price > 0) {
                    prices.push(price);
                }
            } catch (error) {
                console.warn(`Failed to get price from ${exchange}:`, error);
            }
        }
        
        if (prices.length === 0) {
            throw new Error('No valid prices obtained');
        }
        
        // ËøîÂõû‰∏≠‰ΩçÊï∞‰ª∑Ê†º
        return this.calculateMedian(prices);
    }
    
    private async fetchPriceFromExchange(exchange: string): Promise<number> {
        // ÂÆûÁé∞ÂêÑ‰∫§ÊòìÊâÄÁöÑAPIË∞ÉÁî®
        switch (exchange.toLowerCase()) {
            case 'binance':
                return this.fetchFromBinance();
            case 'coinbase':
                return this.fetchFromCoinbase();
            case 'kraken':
                return this.fetchFromKraken();
            default:
                throw new Error(`Unsupported exchange: ${exchange}`);
        }
    }
    
    private async fetchFromBinance(): Promise<number> {
        const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${this.symbol}USDT`);
        const data = await response.json();
        return parseFloat(data.price);
    }
    
    private async fetchFromCoinbase(): Promise<number> {
        const response = await fetch(`https://api.coinbase.com/v2/exchange-rates?currency=${this.symbol}`);
        const data = await response.json();
        return parseFloat(data.data.rates.USD);
    }
    
    private async fetchFromKraken(): Promise<number> {
        const pair = `${this.symbol}USD`;
        const response = await fetch(`https://api.kraken.com/0/public/Ticker?pair=${pair}`);
        const data = await response.json();
        const pairKey = Object.keys(data.result)[0];
        return parseFloat(data.result[pairKey].c[0]);
    }
    
    private calculateMedian(prices: number[]): number {
        const sorted = prices.sort((a, b) => a - b);
        const middle = Math.floor(sorted.length / 2);
        
        if (sorted.length % 2 === 0) {
            return (sorted[middle - 1] + sorted[middle]) / 2;
        } else {
            return sorted[middle];
        }
    }
}

// ÂêØÂä®ËäÇÁÇπ
async function startOracleNode() {
    const node = new OracleNode(
        process.env.ORACLE_PRIVATE_KEY!,
        process.env.ORACLE_CONTRACT_ADDRESS!,
        new ethers.providers.JsonRpcProvider(process.env.RPC_URL)
    );
    
    // Ê∑ªÂä†ETH/USDÊï∞ÊçÆÊ∫ê
    const ethProvider = new ExchangeDataProvider('ETH', ['binance', 'coinbase', 'kraken']);
    node.addDataProvider('ETH/USD', ethProvider);
    
    // Ê∑ªÂä†BTC/USDÊï∞ÊçÆÊ∫ê
    const btcProvider = new ExchangeDataProvider('BTC', ['binance', 'coinbase', 'kraken']);
    node.addDataProvider('BTC/USD', btcProvider);
    
    await node.start();
}

// ÂêØÂä®ËäÇÁÇπ
startOracleNode().catch(console.error);
```



## È¢ÑË®ÄÊú∫Â∫îÁî®Âú∫ÊôØ

### 1. DeFiÂÄüË¥∑ÂçèËÆÆ

```solidity
contract DeFiLendingProtocol {
    using SafeMath for uint256;
    
    struct User {
        mapping(address => uint256) collateral;
        mapping(address => uint256) borrowed;
        uint256 healthFactor;
    }
    
    mapping(address => User) public users;
    mapping(address => address) public priceOracles; // token -> oracle
    mapping(address => uint256) public collateralFactors; // ÊäµÊäºÁéá
    
    uint256 public constant LIQUIDATION_THRESHOLD = 150; // 150%
    uint256 public constant LIQUIDATION_BONUS = 105; // 5% bonus
    
    // Â≠òÂÖ•ÊäµÊäºÂìÅ
    function deposit(address token, uint256 amount) external {
        require(priceOracles[token] != address(0), "Token not supported");
        
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        users[msg.sender].collateral[token] = users[msg.sender].collateral[token].add(amount);
        
        updateHealthFactor(msg.sender);
        emit Deposit(msg.sender, token, amount);
    }
    
    // ÂÄüÂá∫ËµÑ‰∫ß
    function borrow(address token, uint256 amount) external {
        require(priceOracles[token] != address(0), "Token not supported");
        
        uint256 borrowValue = getTokenValue(token, amount);
        uint256 collateralValue = getUserCollateralValue(msg.sender);
        uint256 currentBorrowValue = getUserBorrowValue(msg.sender);
        
        require(
            collateralValue >= currentBorrowValue.add(borrowValue).mul(LIQUIDATION_THRESHOLD).div(100),
            "Insufficient collateral"
        );
        
        users[msg.sender].borrowed[token] = users[msg.sender].borrowed[token].add(amount);
        IERC20(token).transfer(msg.sender, amount);
        
        updateHealthFactor(msg.sender);
        emit Borrow(msg.sender, token, amount);
    }
    
    // Ê∏ÖÁÆó
    function liquidate(
        address borrower,
        address collateralToken,
        address borrowToken,
        uint256 repayAmount
    ) external {
        uint256 healthFactor = calculateHealthFactor(borrower);
        require(healthFactor < 100, "User is healthy");
        
        // ËÆ°ÁÆóÊ∏ÖÁÆóÈáëÈ¢ù
        uint256 maxRepayAmount = users[borrower].borrowed[borrowToken].mul(50).div(100); // ÊúÄÂ§öÊ∏ÖÁÆó50%
        uint256 actualRepayAmount = repayAmount > maxRepayAmount ? maxRepayAmount : repayAmount;
        
        // ËÆ°ÁÆóÊî∂Ëé∑ÁöÑÊäµÊäºÂìÅ
        uint256 collateralAmount = calculateLiquidationAmount(
            borrowToken,
            collateralToken,
            actualRepayAmount
        );
        
        // ÊâßË°åÊ∏ÖÁÆó
        IERC20(borrowToken).transferFrom(msg.sender, address(this), actualRepayAmount);
        IERC20(collateralToken).transfer(msg.sender, collateralAmount);
        
        // Êõ¥Êñ∞Áî®Êà∑Áä∂ÊÄÅ
        users[borrower].borrowed[borrowToken] = users[borrower].borrowed[borrowToken].sub(actualRepayAmount);
        users[borrower].collateral[collateralToken] = users[borrower].collateral[collateralToken].sub(collateralAmount);
        
        updateHealthFactor(borrower);
        
        emit Liquidation(borrower, msg.sender, borrowToken, collateralToken, actualRepayAmount, collateralAmount);
    }
    
    function calculateHealthFactor(address user) public view returns (uint256) {
        uint256 collateralValue = getUserCollateralValue(user);
        uint256 borrowValue = getUserBorrowValue(user);
        
        if (borrowValue == 0) return type(uint256).max;
        
        return collateralValue.mul(100).div(borrowValue);
    }
    
    function getUserCollateralValue(address user) public view returns (uint256) {
        uint256 totalValue = 0;
        
        // ËøôÈáåÁÆÄÂåñ‰∏∫Âè™Ê£ÄÊü•‰∏ªË¶Å‰ª£Â∏ÅÔºåÂÆûÈôÖÂ∫îËØ•ÈÅçÂéÜÊâÄÊúâÊîØÊåÅÁöÑ‰ª£Â∏Å
        address[] memory tokens = getSupportedTokens();
        
        for (uint i = 0; i < tokens.length; i++) {
            uint256 balance = users[user].collateral[tokens[i]];
            if (balance > 0) {
                uint256 value = getTokenValue(tokens[i], balance);
                totalValue = totalValue.add(value.mul(collateralFactors[tokens[i]]).div(100));
            }
        }
        
        return totalValue;
    }
    
    function getUserBorrowValue(address user) public view returns (uint256) {
        uint256 totalValue = 0;
        
        address[] memory tokens = getSupportedTokens();
        
        for (uint i = 0; i < tokens.length; i++) {
            uint256 balance = users[user].borrowed[tokens[i]];
            if (balance > 0) {
                totalValue = totalValue.add(getTokenValue(tokens[i], balance));
            }
        }
        
        return totalValue;
    }
    
    function getTokenValue(address token, uint256 amount) public view returns (uint256) {
        address oracle = priceOracles[token];
        require(oracle != address(0), "No oracle for token");
        
        AggregatorV3Interface priceFeed = AggregatorV3Interface(oracle);
        (, int256 price,,,) = priceFeed.latestRoundData();
        
        require(price > 0, "Invalid price");
        
        uint8 decimals = priceFeed.decimals();
        return amount.mul(uint256(price)).div(10**decimals);
    }
    
    function calculateLiquidationAmount(
        address borrowToken,
        address collateralToken,
        uint256 repayAmount
    ) internal view returns (uint256) {
        uint256 borrowValue = getTokenValue(borrowToken, repayAmount);
        uint256 collateralPrice = getTokenPrice(collateralToken);
        
        // Ê∑ªÂä†5%Ê∏ÖÁÆóÂ•ñÂä±
        uint256 collateralValue = borrowValue.mul(LIQUIDATION_BONUS).div(100);
        
        return collateralValue.mul(1e18).div(collateralPrice);
    }
    
    function updateHealthFactor(address user) internal {
        users[user].healthFactor = calculateHealthFactor(user);
    }
}
```

### 2. È¢ÑÊµãÂ∏ÇÂú∫

```solidity
contract PredictionMarket {
    using SafeMath for uint256;
    
    enum MarketState { Open, Closed, Resolved, Disputed }
    
    struct Market {
        string question;
        string[] outcomes;
        uint256 endTime;
        uint256 resolutionTime;
        MarketState state;
        uint256 resolvedOutcome;
        address oracle;
        uint256 totalStaked;
        mapping(uint256 => uint256) outcomeShares;
        mapping(address => mapping(uint256 => uint256)) userShares;
        uint256 disputeEnd;
    }
    
    mapping(uint256 => Market) public markets;
    uint256 public marketCounter;
    
    uint256 public constant DISPUTE_PERIOD = 3 days;
    uint256 public constant MIN_RESOLUTION_TIME = 1 hours;
    
    event MarketCreated(uint256 indexed marketId, string question, uint256 endTime);
    event SharesPurchased(uint256 indexed marketId, address user, uint256 outcome, uint256 shares, uint256 cost);
    event MarketResolved(uint256 indexed marketId, uint256 outcome);
    event DisputeRaised(uint256 indexed marketId, address disputer);
    
    // ÂàõÂª∫Â∏ÇÂú∫
    function createMarket(
        string memory question,
        string[] memory outcomes,
        uint256 duration,
        address oracle
    ) external returns (uint256) {
        require(outcomes.length >= 2, "Need at least 2 outcomes");
        require(duration >= MIN_RESOLUTION_TIME, "Duration too short");
        
        uint256 marketId = marketCounter++;
        Market storage market = markets[marketId];
        
        market.question = question;
        market.outcomes = outcomes;
        market.endTime = block.timestamp.add(duration);
        market.resolutionTime = market.endTime.add(MIN_RESOLUTION_TIME);
        market.state = MarketState.Open;
        market.oracle = oracle;
        
        emit MarketCreated(marketId, question, market.endTime);
        return marketId;
    }
    
    // Ë¥≠‰π∞‰ªΩÈ¢ù
    function buyShares(
        uint256 marketId,
        uint256 outcome,
        uint256 shares
    ) external payable {
        Market storage market = markets[marketId];
        require(market.state == MarketState.Open, "Market not open");
        require(block.timestamp < market.endTime, "Market ended");
        require(outcome < market.outcomes.length, "Invalid outcome");
        
        uint256 cost = calculateCost(marketId, outcome, shares);
        require(msg.value >= cost, "Insufficient payment");
        
        market.userShares[msg.sender][outcome] = market.userShares[msg.sender][outcome].add(shares);
        market.outcomeShares[outcome] = market.outcomeShares[outcome].add(shares);
        market.totalStaked = market.totalStaked.add(msg.value);
        
        emit SharesPurchased(marketId, msg.sender, outcome, shares, cost);
        
        // ÈÄÄËøòÂ§ö‰ΩôÁöÑETH
        if (msg.value > cost) {
            payable(msg.sender).transfer(msg.value.sub(cost));
        }
    }
    
    // ËÆ°ÁÆóË¥≠‰π∞ÊàêÊú¨Ôºà‰ΩøÁî®Ëá™Âä®ÂåñÂÅöÂ∏ÇÂïÜÂÖ¨ÂºèÔºâ
    function calculateCost(
        uint256 marketId,
        uint256 outcome,
        uint256 shares
    ) public view returns (uint256) {
        Market storage market = markets[marketId];
        
        // ÁÆÄÂåñÁöÑÂ∏∏Êï∞‰πòÁßØÂÖ¨Âºè
        uint256 currentShares = market.outcomeShares[outcome];
        uint256 k = 1000000; // Â∏∏Êï∞
        
        if (currentShares == 0) {
            return shares.mul(1e15); // ÂàùÂßã‰ª∑Ê†º
        }
        
        // ËÆ°ÁÆóÊñ∞ÁöÑ‰ª∑Ê†º
        uint256 newPrice = k.div(currentShares.add(shares));
        uint256 oldPrice = k.div(currentShares);
        
        return shares.mul(newPrice.add(oldPrice)).div(2);
    }
    
    // Ëß£ÂÜ≥Â∏ÇÂú∫
    function resolveMarket(uint256 marketId, uint256 outcome) external {
        Market storage market = markets[marketId];
        require(msg.sender == market.oracle, "Only oracle can resolve");
        require(market.state == MarketState.Closed, "Market not closed");
        require(block.timestamp >= market.resolutionTime, "Too early to resolve");
        require(outcome < market.outcomes.length, "Invalid outcome");
        
        market.resolvedOutcome = outcome;
        market.state = MarketState.Resolved;
        market.disputeEnd = block.timestamp.add(DISPUTE_PERIOD);
        
        emit MarketResolved(marketId, outcome);
    }
    
    // ÂÖ≥Èó≠Â∏ÇÂú∫ÔºàÁªìÊùüÊäïÊ≥®ÊúüÔºâ
    function closeMarket(uint256 marketId) external {
        Market storage market = markets[marketId];
        require(market.state == MarketState.Open, "Market not open");
        require(block.timestamp >= market.endTime, "Market not ended");
        
        market.state = MarketState.Closed;
    }
    
    // ÊèêÂá∫‰∫âËÆÆ
    function dispute(uint256 marketId) external payable {
        Market storage market = markets[marketId];
        require(market.state == MarketState.Resolved, "Market not resolved");
        require(block.timestamp <= market.disputeEnd, "Dispute period ended");
        require(msg.value >= 0.1 ether, "Insufficient dispute bond");
        
        market.state = MarketState.Disputed;
        emit DisputeRaised(marketId, msg.sender);
        
        // ÂÆûÈôÖÂÆûÁé∞‰∏≠ÔºåËøôÈáåÂ∫îËØ•ÂêØÂä®‰∫âËÆÆËß£ÂÜ≥ÊµÅÁ®ã
    }
    
    // È¢ÜÂèñÂ•ñÂä±
    function claimRewards(uint256 marketId) external {
        Market storage market = markets[marketId];
        require(market.state == MarketState.Resolved, "Market not finalized");
        require(block.timestamp > market.disputeEnd, "Dispute period not ended");
        
        uint256 userShares = market.userShares[msg.sender][market.resolvedOutcome];
        require(userShares > 0, "No winning shares");
        
        uint256 totalWinningShares = market.outcomeShares[market.resolvedOutcome];
        uint256 reward = market.totalStaked.mul(userShares).div(totalWinningShares);
        
        market.userShares[msg.sender][market.resolvedOutcome] = 0;
        payable(msg.sender).transfer(reward);
    }
    
    // Ëé∑ÂèñÂ∏ÇÂú∫‰ø°ÊÅØ
    function getMarketInfo(uint256 marketId) 
        external 
        view 
        returns (
            string memory question,
            string[] memory outcomes,
            uint256 endTime,
            MarketState state,
            uint256 totalStaked
        ) 
    {
        Market storage market = markets[marketId];
        return (
            market.question,
            market.outcomes,
            market.endTime,
            market.state,
            market.totalStaked
        );
    }
}
```

### 3. ÂèÇÊï∞Âåñ‰øùÈô©

```solidity
contract ParametricInsurance {
    using SafeMath for uint256;
    
    struct Policy {
        address holder;
        string location;
        uint256 premium;
        uint256 coverageAmount;
        uint256 startTime;
        uint256 endTime;
        string triggerCondition; // e.g., "temperature > 40"
        bool active;
        bool claimed;
        address weatherOracle;
    }
    
    mapping(uint256 => Policy) public policies;
    uint256 public policyCounter;
    
    mapping(string => address) public weatherOracles; // location -> oracle
    mapping(address => bool) public authorizedOracles;
    
    event PolicyCreated(uint256 indexed policyId, address holder, string location, uint256 coverage);
    event ClaimTriggered(uint256 indexed policyId, uint256 payout);
    event WeatherDataReceived(string location, uint256 temperature, uint256 timestamp);
    
    // ÂàõÂª∫‰øùÈô©ÊîøÁ≠ñ
    function createPolicy(
        string memory location,
        uint256 coverageAmount,
        uint256 duration,
        string memory triggerCondition
    ) external payable {
        require(weatherOracles[location] != address(0), "No oracle for location");
        require(msg.value > 0, "Premium required");
        require(coverageAmount > 0, "Coverage amount required");
        
        uint256 policyId = policyCounter++;
        
        policies[policyId] = Policy({
            holder: msg.sender,
            location: location,
            premium: msg.value,
            coverageAmount: coverageAmount,
            startTime: block.timestamp,
            endTime: block.timestamp.add(duration),
            triggerCondition: triggerCondition,
            active: true,
            claimed: false,
            weatherOracle: weatherOracles[location]
        });
        
        emit PolicyCreated(policyId, msg.sender, location, coverageAmount);
    }
    
    // È¢ÑË®ÄÊú∫Êä•ÂëäÂ§©Ê∞îÊï∞ÊçÆ
    function reportWeatherData(
        string memory location,
        uint256 temperature,
        uint256 timestamp
    ) external {
        require(authorizedOracles[msg.sender], "Not authorized oracle");
        require(timestamp <= block.timestamp, "Future timestamp");
        require(timestamp >= block.timestamp.sub(1 hours), "Data too old");
        
        emit WeatherDataReceived(location, temperature, timestamp);
        
        // Ê£ÄÊü•ÊòØÂê¶Ëß¶Âèë‰ªª‰Ωï‰øùÈô©ÊîøÁ≠ñ
        checkPoliciesForLocation(location, temperature, timestamp);
    }
    
    // Ê£ÄÊü•ÁâπÂÆö‰ΩçÁΩÆÁöÑÊâÄÊúâÊîøÁ≠ñ
    function checkPoliciesForLocation(
        string memory location,
        uint256 temperature,
        uint256 timestamp
    ) internal {
        for (uint256 i = 0; i < policyCounter; i++) {
            Policy storage policy = policies[i];
            
            if (!policy.active || policy.claimed) continue;
            if (keccak256(bytes(policy.location)) != keccak256(bytes(location))) continue;
            if (timestamp < policy.startTime || timestamp > policy.endTime) continue;
            
            // Ê£ÄÊü•Ëß¶ÂèëÊù°‰ª∂
            if (checkTriggerCondition(policy.triggerCondition, temperature)) {
                triggerPayout(i);
            }
        }
    }
    
    // Ê£ÄÊü•Ëß¶ÂèëÊù°‰ª∂
    function checkTriggerCondition(
        string memory condition,
        uint256 temperature
    ) internal pure returns (bool) {
        // ÁÆÄÂåñÁöÑÊù°‰ª∂Ëß£Êûê
        // ÂÆûÈôÖÂÆûÁé∞ÈúÄË¶ÅÊõ¥Â§çÊùÇÁöÑËß£ÊûêÂô®
        
        if (keccak256(bytes(condition)) == keccak256(bytes("temperature > 40"))) {
            return temperature > 40;
        } else if (keccak256(bytes(condition)) == keccak256(bytes("temperature < 0"))) {
            return temperature == 0; // ÂÅáËÆæ0Ë°®Á§∫ÂÜ∞ÁÇπ‰ª•‰∏ã
        }
        
        return false;
    }
    
    // Ëß¶ÂèëËµî‰ªò
    function triggerPayout(uint256 policyId) internal {
        Policy storage policy = policies[policyId];
        require(policy.active && !policy.claimed, "Policy not eligible");
        
        policy.claimed = true;
        policy.active = false;
        
        // ËÆ°ÁÆóËµî‰ªòÈáëÈ¢ù
        uint256 payout = policy.coverageAmount;
        
        // Ê£ÄÊü•ÂêàÁ∫¶‰ΩôÈ¢ù
        if (address(this).balance >= payout) {
            payable(policy.holder).transfer(payout);
            emit ClaimTriggered(policyId, payout);
        }
    }
    
    // ÊâãÂä®Ê£ÄÊü•ÊîøÁ≠ñÁä∂ÊÄÅ
    function checkPolicy(uint256 policyId) external view returns (bool shouldPayout) {
        Policy storage policy = policies[policyId];
        require(policy.active && !policy.claimed, "Policy not active");
        
        // ‰ªéÈ¢ÑË®ÄÊú∫Ëé∑ÂèñÊúÄÊñ∞Êï∞ÊçÆ
        address oracle = weatherOracles[policy.location];
        // ËøôÈáåÈúÄË¶ÅË∞ÉÁî®È¢ÑË®ÄÊú∫Ëé∑ÂèñÊúÄÊñ∞Â§©Ê∞îÊï∞ÊçÆ
        // ÁÆÄÂåñÂÆûÁé∞
        
        return false;
    }
    
    // ÂèñÊ∂àÊîøÁ≠ñÔºàÈÉ®ÂàÜÈÄÄÊ¨æÔºâ
    function cancelPolicy(uint256 policyId) external {
        Policy storage policy = policies[policyId];
        require(msg.sender == policy.holder, "Not policy holder");
        require(policy.active, "Policy not active");
        require(block.timestamp < policy.endTime, "Policy expired");
        
        policy.active = false;
        
        // ËÆ°ÁÆóÈÄÄÊ¨æÈáëÈ¢ùÔºàÊåâÊó∂Èó¥ÊØî‰æãÔºâ
        uint256 remainingTime = policy.endTime.sub(block.timestamp);
        uint256 totalTime = policy.endTime.sub(policy.startTime);
        uint256 refund = policy.premium.mul(remainingTime).div(totalTime).mul(80).div(100); // 80%ÈÄÄÊ¨æ
        
        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }
    }
    
    // Ê∑ªÂä†Â§©Ê∞îÈ¢ÑË®ÄÊú∫
    function addWeatherOracle(string memory location, address oracle) external {
        // Âè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Ê∑ªÂä†
        weatherOracles[location] = oracle;
        authorizedOracles[oracle] = true;
    }
}
```



## Êú™Êù•ÂèëÂ±ïË∂ãÂäø

### 1. Ë∑®ÈìæÈ¢ÑË®ÄÊú∫

```solidity
// Ë∑®ÈìæÈ¢ÑË®ÄÊú∫Ê°•Êé•
contract CrossChainOracle {
    // ÊîØÊåÅÁöÑÂå∫ÂùóÈìæ
    enum Chain { Ethereum, BSC, Polygon, Arbitrum, Optimism }
    
    struct CrossChainPrice {
        uint256 price;
        Chain sourceChain;
        uint256 timestamp;
        bytes32 merkleProof;
    }
    
    mapping(string => mapping(Chain => CrossChainPrice)) public crossChainPrices;
    mapping(Chain => address) public chainBridges;
    
    // Êé•Êî∂Ë∑®Èìæ‰ª∑Ê†ºÊï∞ÊçÆ
    function receiveCrossChainPrice(
        string memory symbol,
        Chain sourceChain,
        uint256 price,
        uint256 timestamp,
        bytes32 merkleProof
    ) external {
        require(msg.sender == chainBridges[sourceChain], "Invalid bridge");
        
        // È™åËØÅMerkleËØÅÊòé
        require(verifyMerkleProof(symbol, price, timestamp, merkleProof), "Invalid proof");
        
        crossChainPrices[symbol][sourceChain] = CrossChainPrice({
            price: price,
            sourceChain: sourceChain,
            timestamp: timestamp,
            merkleProof: merkleProof
        });
        
        emit CrossChainPriceReceived(symbol, sourceChain, price, timestamp);
    }
    
    // ËÅöÂêàË∑®Èìæ‰ª∑Ê†º
    function getAggregatedPrice(string memory symbol) 
        external 
        view 
        returns (uint256) 
    {
        uint256[] memory prices = new uint256[](5);
        uint8 validPrices = 0;
        
        // Êî∂ÈõÜÂêÑÈìæÁöÑ‰ª∑Ê†º
        for (uint i = 0; i < 5; i++) {
            CrossChainPrice memory price = crossChainPrices[symbol][Chain(i)];
            if (price.timestamp > 0 && block.timestamp - price.timestamp < 1 hours) {
                prices[validPrices] = price.price;
                validPrices++;
            }
        }
        
        require(validPrices >= 3, "Insufficient cross-chain data");
        
        // ËøîÂõû‰∏≠‰ΩçÊï∞‰ª∑Ê†º
        return calculateMedian(prices, validPrices);
    }
    
    function verifyMerkleProof(
        string memory symbol,
        uint256 price,
        uint256 timestamp,
        bytes32 merkleProof
    ) internal pure returns (bool) {
        // ÁÆÄÂåñÁöÑMerkleËØÅÊòéÈ™åËØÅ
        bytes32 leaf = keccak256(abi.encodePacked(symbol, price, timestamp));
        // ÂÆûÈôÖÈúÄË¶ÅÂÆåÊï¥ÁöÑMerkleÊ†ëÈ™åËØÅÈÄªËæë
        return true;
    }
    
    event CrossChainPriceReceived(string symbol, Chain sourceChain, uint256 price, uint256 timestamp);
}
```

### 2. AIÈ©±Âä®ÁöÑÈ¢ÑË®ÄÊú∫

```solidity
contract AIOracle {
    struct Prediction {
        string query;
        uint256 confidence;
        bytes result;
        string model;
        uint256 timestamp;
    }
    
    mapping(bytes32 => Prediction) public predictions;
    mapping(address => bool) public aiNodes;
    
    // AIËäÇÁÇπÊèê‰∫§È¢ÑÊµãÁªìÊûú
    function submitPrediction(
        string memory query,
        bytes memory result,
        uint256 confidence,
        string memory model,
        bytes memory proof
    ) external {
        require(aiNodes[msg.sender], "Not authorized AI node");
        require(confidence <= 100, "Invalid confidence");
        
        bytes32 queryHash = keccak256(bytes(query));
        
        // È™åËØÅAIÊ®°ÂûãËæìÂá∫ÁöÑÈõ∂Áü•ËØÜËØÅÊòé
        require(verifyAIProof(result, proof, model), "Invalid AI proof");
        
        predictions[queryHash] = Prediction({
            query: query,
            confidence: confidence,
            result: result,
            model: model,
            timestamp: block.timestamp
        });
        
        emit PredictionSubmitted(queryHash, msg.sender, confidence);
    }
    
    function verifyAIProof(
        bytes memory result,
        bytes memory proof,
        string memory model
    ) internal pure returns (bool) {
        // Èõ∂Áü•ËØÜËØÅÊòéÈ™åËØÅAIÊ®°ÂûãÁöÑÊ≠£Á°ÆÊâßË°å
        // ËøôÈúÄË¶ÅÂ§çÊùÇÁöÑÂØÜÁ†ÅÂ≠¶ÂÆûÁé∞
        return true;
    }
    
    event PredictionSubmitted(bytes32 indexed queryHash, address aiNode, uint256 confidence);
}
```

### 3. ÈöêÁßÅ‰øùÊä§È¢ÑË®ÄÊú∫

```solidity
contract PrivacyPreservingOracle {
    using Verifier for bytes32;
    
    struct EncryptedSubmission {
        bytes32 commitment;
        bytes encryptedData;
        bytes zkProof;
        uint256 timestamp;
    }
    
    mapping(address => mapping(string => EncryptedSubmission)) public submissions;
    
    // Êèê‰∫§Âä†ÂØÜÊï∞ÊçÆ
    function submitEncryptedData(
        string memory feedId,
        bytes32 commitment,
        bytes memory encryptedData,
        bytes memory zkProof
    ) external {
        require(authorizedOracles[msg.sender], "Not authorized");
        
        // È™åËØÅÈõ∂Áü•ËØÜËØÅÊòé
        require(verifyZKProof(commitment, zkProof), "Invalid ZK proof");
        
        submissions[msg.sender][feedId] = EncryptedSubmission({
            commitment: commitment,
            encryptedData: encryptedData,
            zkProof: zkProof,
            timestamp: block.timestamp
        });
        
        emit EncryptedDataSubmitted(feedId, msg.sender, commitment);
    }
    
    // ÂÆâÂÖ®Â§öÊñπËÆ°ÁÆóËÅöÂêà
    function aggregateEncryptedData(
        string memory feedId,
        address[] memory oracles
    ) external returns (bytes32 result) {
        // ‰ΩøÁî®ÂêåÊÄÅÂä†ÂØÜËøõË°åÊï∞ÊçÆËÅöÂêà
        // ÂÆûÈôÖÈúÄË¶ÅÂ§çÊùÇÁöÑÂØÜÁ†ÅÂ≠¶ÂçèËÆÆ
        
        for (uint i = 0; i < oracles.length; i++) {
            EncryptedSubmission storage sub = submissions[oracles[i]][feedId];
            require(sub.timestamp > 0, "Missing submission");
            
            // ÂêåÊÄÅÂä†ÂØÜËøêÁÆó
            result = homomorphicAdd(result, sub.commitment);
        }
        
        emit EncryptedAggregationComplete(feedId, result);
        return result;
    }
    
    function homomorphicAdd(bytes32 a, bytes32 b) internal pure returns (bytes32) {
        // ÁÆÄÂåñÁöÑÂêåÊÄÅÂä†ÂØÜÂä†Ê≥ï
        return keccak256(abi.encodePacked(a, b));
    }
    
    function verifyZKProof(bytes32 commitment, bytes memory proof) 
        internal 
        pure 
        returns (bool) 
    {
        // Èõ∂Áü•ËØÜËØÅÊòéÈ™åËØÅ
        return true;
    }
    
    event EncryptedDataSubmitted(string feedId, address oracle, bytes32 commitment);
    event EncryptedAggregationComplete(string feedId, bytes32 result);
}
```



## ÊÄªÁªì

È¢ÑË®ÄÊú∫ÊòØWeb3ÁîüÊÄÅÁ≥ªÁªü‰∏≠ÁöÑÂÖ≥ÈîÆÂü∫Á°ÄËÆæÊñΩÔºåÂÆÉ‰ª¨Ëß£ÂÜ≥‰∫ÜÂå∫ÂùóÈìæ‰∏éÁé∞ÂÆû‰∏ñÁïåÊï∞ÊçÆ‰∫§‰∫íÁöÑÊ†πÊú¨ÈóÆÈ¢ò„ÄÇÈöèÁùÄDeFi„ÄÅGameFiÂíåÂÖ∂‰ªñÈìæ‰∏äÂ∫îÁî®ÁöÑÂø´ÈÄüÂèëÂ±ïÔºåÈ¢ÑË®ÄÊú∫ÁöÑÈáçË¶ÅÊÄßÂíåÂ§çÊùÇÊÄßÈÉΩÂú®‰∏çÊñ≠ÊèêÂçá„ÄÇ

### Ê†∏ÂøÉË¶ÅÁÇπ

1. **Âü∫Êú¨ÂäüËÉΩ**
   - Êï∞ÊçÆËé∑ÂèñÂíåÈ™åËØÅ
   - Â§öÊ∫êËÅöÂêàÂíåÂÖ±ËØÜ
   - ÊäóÊìçÁ∫µÂÆâÂÖ®Êú∫Âà∂
   - ÂÆûÊó∂Êõ¥Êñ∞ÂíåÂèØÈù†ÊÄß

2. **ÂÆâÂÖ®ÊåëÊàò**
   - È¢ÑË®ÄÊú∫ÈóÆÈ¢òÁöÑÊú¨Ë¥®
   - ‰ª∑Ê†ºÊìçÁ∫µÊîªÂáªÈò≤Êä§
   - ÂçïÁÇπÊïÖÈöúÈ£éÈô©ÁÆ°ÁêÜ
   - Êï∞ÊçÆÊù•Ê∫êÂèØ‰ø°Â∫¶È™åËØÅ

3. **ÊäÄÊúØÂèëÂ±ï**
   - Âéª‰∏≠ÂøÉÂåñÈ¢ÑË®ÄÊú∫ÁΩëÁªú
   - Ë∑®ÈìæÊï∞ÊçÆÂêåÊ≠•
   - ÈöêÁßÅ‰øùÊä§ÊäÄÊúØ
   - AIÂíåÊú∫Âô®Â≠¶‰π†ÈõÜÊàê

4. **Â∫îÁî®Âú∫ÊôØ**
   - DeFiÂÄüË¥∑ÂíåÊ∏ÖÁÆó
   - È¢ÑÊµãÂ∏ÇÂú∫Âíå‰øùÈô©
   - Ê∏∏ÊàèÂíåNFTÂÖÉÊï∞ÊçÆ
   - Áâ©ËÅîÁΩëÊï∞ÊçÆÈõÜÊàê

È¢ÑË®ÄÊú∫ÊäÄÊúØÁöÑÊú™Êù•ÂèëÂ±ïÂ∞ÜÂõ¥ÁªïÊõ¥È´òÁöÑÂÆâÂÖ®ÊÄß„ÄÅÊõ¥Â•ΩÁöÑÈöêÁßÅ‰øùÊä§„ÄÅÊõ¥Âº∫ÁöÑË∑®Èìæ‰∫íÊìç‰ΩúÊÄß‰ª•ÂèäÊõ¥Êô∫ËÉΩÁöÑÊï∞ÊçÆÂ§ÑÁêÜËÉΩÂäõÂ±ïÂºÄ„ÄÇÂºÄÂèëËÄÖÂú®ÈÄâÊã©ÂíåÈõÜÊàêÈ¢ÑË®ÄÊú∫ÊúçÂä°Êó∂ÔºåÈúÄË¶ÅÂÖÖÂàÜËÄÉËôëÂ∫îÁî®Âú∫ÊôØÁöÑÁâπÂÆöÈúÄÊ±ÇÔºåÂπ≥Ë°°ÂÆâÂÖ®ÊÄß„ÄÅÊàêÊú¨ÂíåÊÄßËÉΩÁ≠âÂõ†Á¥†„ÄÇ