# EIP-191 签名数据标准

EIP-191是以太坊改进提案191，定义了签名数据的标准格式。它是所有以太坊签名机制的基础标准，通过引入特定的前缀格式来防止签名数据被误解为有效的RLP编码交易，从而提供关键的安全保护。

## 背景与动机

### 问题背景
在EIP-191之前，以太坊生态系统中缺乏统一的签名数据标准，这导致了几个关键问题：

1. **交易重放攻击风险**：签名数据可能被误解为有效的以太坊交易
2. **多重签名钱包安全隐患**：预签名交易可能在具有相同成员的不同多重签名钱包间被重用
3. **缺乏标准化**：不同应用和钱包有各自的签名格式

### EIP-191的解决方案
EIP-191通过定义统一的签名数据格式解决了这些问题：
- 使用`0x19`前缀确保签名数据不是有效的RLP编码
- 提供版本化的扩展机制
- 建立了签名验证的安全基础

## 核心技术规范

### 1. 数据格式结构
EIP-191定义的签名数据格式为：
```
0x19 <1字节版本> <版本特定数据> <要签名的数据>
```

#### 格式解析：
- `0x19`：固定前缀字节
- `<1字节版本>`：版本标识符
- `<版本特定数据>`：根据版本不同而变化的数据
- `<要签名的数据>`：实际需要签名的内容

### 2. 0x19前缀的技术原理

#### RLP编码保护
```javascript
// 0x19的选择原因：
// 1. 在RLP编码中，0x19不是有效的单字节RLP结构
// 2. 对于值在[0x00, 0x7f]范围内的单字节，该字节本身就是其RLP编码
// 3. 0x19使得任何signed_data都不能是单一的RLP结构
```

#### 交易重放防护
```solidity
// 以太坊交易使用RLP编码，格式如下：
// RLP([nonce, gasPrice, gasLimit, to, value, data, v, r, s])
// 
// EIP-191的0x19前缀确保签名数据永远不会被误解为交易
bytes memory invalidRLP = abi.encodePacked(
    bytes1(0x19),  // 使RLP无效的前缀
    version,       // 版本字节
    versionData,   // 版本特定数据
    dataToSign     // 实际数据
);
```

## 版本系统

### 版本 0x00：验证器地址
```
0x19 <0x00> <intended validator address> <data to sign>
```

#### 使用场景：
- 多重签名钱包
- 智能合约验证
- 特定验证器的签名

#### 实现示例：
```solidity
contract ValidatorExample {
    function validateSignature(
        bytes32 hash,
        bytes memory signature,
        address signer
    ) public view returns (bool) {
        // 构造EIP-191格式的消息
        bytes32 message = keccak256(abi.encodePacked(
            bytes1(0x19),
            bytes1(0x00),
            address(this),  // 验证器地址
            hash
        ));
        
        // 恢复签名者地址
        address recovered = ECDSA.recover(message, signature);
        return recovered == signer;
    }
}
```

### 版本 0x01：结构化数据
```
0x19 <0x01> <domainSeparator> <hashStruct(message)>
```

#### 使用场景：
- EIP-712类型化数据签名
- DApp结构化消息
- 复杂数据结构签名

#### 实现示例：
```javascript
// EIP-712使用EIP-191的0x01版本
const domain = {
    name: "MyDApp",
    version: "1",
    chainId: 1,
    verifyingContract: "0x123..."
};

// 域分隔符计算
const domainSeparator = ethers.utils._TypedDataEncoder.hashDomain(domain);

// EIP-191格式：0x19 0x01 domainSeparator hashStruct(message)
const eip191Message = ethers.utils.solidityPack(
    ['bytes1', 'bytes1', 'bytes32', 'bytes32'],
    ['0x19', '0x01', domainSeparator, structHash]
);
```

### 版本 0x45：以太坊签名消息
```
0x19 <0x45> <"thereum Signed Message:\n" + len(message)> <message>
```

#### 使用场景：
- 个人消息签名
- 钱包标准签名
- 用户身份验证

#### 实现示例：
```javascript
// MetaMask和其他钱包使用的标准格式
function createEthereumSignedMessage(message) {
    const messageBytes = ethers.utils.toUtf8Bytes(message);
    const prefix = ethers.utils.toUtf8Bytes(
        "\x19Ethereum Signed Message:\n" + messageBytes.length
    );
    
    return ethers.utils.keccak256(
        ethers.utils.concat([prefix, messageBytes])
    );
}

// 使用示例
const message = "Hello World";
const messageHash = createEthereumSignedMessage(message);
const signature = await signer.signMessage(message);
```

## 实际代码实现

### 1. JavaScript/TypeScript实现

#### 基础签名验证
```javascript
const ethers = require('ethers');

class EIP191Handler {
    // 版本0x00：验证器签名
    static createValidatorMessage(validatorAddress, data) {
        return ethers.utils.solidityPack(
            ['bytes1', 'bytes1', 'address', 'bytes'],
            ['0x19', '0x00', validatorAddress, data]
        );
    }
    
    // 版本0x01：结构化数据
    static createStructuredMessage(domainSeparator, structHash) {
        return ethers.utils.solidityPack(
            ['bytes1', 'bytes1', 'bytes32', 'bytes32'],
            ['0x19', '0x01', domainSeparator, structHash]
        );
    }
    
    // 版本0x45：个人消息
    static createPersonalMessage(message) {
        const messageBytes = ethers.utils.toUtf8Bytes(message);
        const prefix = ethers.utils.toUtf8Bytes(
            `\x19Ethereum Signed Message:\n${messageBytes.length}`
        );
        return ethers.utils.keccak256(
            ethers.utils.concat([prefix, messageBytes])
        );
    }
    
    // 验证签名
    static verifySignature(messageHash, signature, expectedSigner) {
        try {
            const recoveredAddress = ethers.utils.recoverAddress(messageHash, signature);
            return recoveredAddress.toLowerCase() === expectedSigner.toLowerCase();
        } catch (error) {
            console.error('签名验证失败:', error);
            return false;
        }
    }
}

// 使用示例
async function demonstrateEIP191() {
    const signer = new ethers.Wallet('0x' + '1'.repeat(64));
    
    // 个人消息签名
    const message = "验证我的身份";
    const messageHash = EIP191Handler.createPersonalMessage(message);
    const signature = await signer.signMessage(message);
    
    const isValid = EIP191Handler.verifySignature(
        messageHash, 
        signature, 
        signer.address
    );
    
    console.log('签名验证结果:', isValid);
}
```

### 2. Solidity合约实现

#### 多版本支持合约
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract EIP191Verifier {
    using ECDSA for bytes32;
    
    // 版本常量
    bytes1 constant VERSION_VALIDATOR = 0x00;
    bytes1 constant VERSION_STRUCTURED = 0x01;  
    bytes1 constant VERSION_PERSONAL = 0x45;
    
    // 错误定义
    error InvalidSignature();
    error UnsupportedVersion();
    
    // 事件
    event SignatureVerified(address indexed signer, bytes1 version);
    
    /**
     * @dev 验证器地址签名（版本0x00）
     */
    function verifyValidatorSignature(
        address validator,
        bytes memory data,
        bytes memory signature,
        address expectedSigner
    ) public returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(
            bytes1(0x19),
            VERSION_VALIDATOR,
            validator,
            data
        ));
        
        address recovered = hash.recover(signature);
        bool isValid = recovered == expectedSigner;
        
        if (isValid) {
            emit SignatureVerified(expectedSigner, VERSION_VALIDATOR);
        }
        
        return isValid;
    }
    
    /**
     * @dev 结构化数据签名（版本0x01）
     */
    function verifyStructuredSignature(
        bytes32 domainSeparator,
        bytes32 structHash,
        bytes memory signature,
        address expectedSigner
    ) public returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(
            bytes1(0x19),
            VERSION_STRUCTURED,
            domainSeparator,
            structHash
        ));
        
        address recovered = hash.recover(signature);
        bool isValid = recovered == expectedSigner;
        
        if (isValid) {
            emit SignatureVerified(expectedSigner, VERSION_STRUCTURED);
        }
        
        return isValid;
    }
    
    /**
     * @dev 个人消息签名（版本0x45）
     */
    function verifyPersonalSignature(
        string memory message,
        bytes memory signature,
        address expectedSigner
    ) public returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(
            bytes1(0x19),
            "Ethereum Signed Message:\n",
            bytes(message).length,
            bytes(message)
        ));
        
        address recovered = hash.recover(signature);
        bool isValid = recovered == expectedSigner;
        
        if (isValid) {
            emit SignatureVerified(expectedSigner, VERSION_PERSONAL);
        }
        
        return isValid;
    }
    
    /**
     * @dev 通用签名验证
     */
    function verifySignature(
        bytes1 version,
        bytes memory versionData,
        bytes memory dataToSign,
        bytes memory signature,
        address expectedSigner
    ) public pure returns (bool) {
        bytes32 hash;
        
        if (version == VERSION_VALIDATOR) {
            require(versionData.length == 20, "Invalid validator address length");
            address validator = abi.decode(versionData, (address));
            hash = keccak256(abi.encodePacked(
                bytes1(0x19),
                version,
                validator,
                dataToSign
            ));
        } else if (version == VERSION_STRUCTURED) {
            require(versionData.length == 32, "Invalid domain separator length");
            bytes32 domainSeparator = abi.decode(versionData, (bytes32));
            hash = keccak256(abi.encodePacked(
                bytes1(0x19),
                version,
                domainSeparator,
                dataToSign
            ));
        } else if (version == VERSION_PERSONAL) {
            hash = keccak256(abi.encodePacked(
                bytes1(0x19),
                "Ethereum Signed Message:\n",
                dataToSign.length,
                dataToSign
            ));
        } else {
            revert UnsupportedVersion();
        }
        
        address recovered = hash.recover(signature);
        return recovered == expectedSigner;
    }
}
```

### 3. 多重签名钱包示例
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MultiSigWallet {
    using ECDSA for bytes32;
    
    address[] public owners;
    uint256 public required;
    uint256 public nonce;
    
    mapping(address => bool) public isOwner;
    
    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        uint256 nonce;
    }
    
    constructor(address[] memory _owners, uint256 _required) {
        require(_owners.length > 0, "Owners required");
        require(_required > 0 && _required <= _owners.length, "Invalid required number");
        
        for (uint256 i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            require(owner != address(0), "Invalid owner");
            require(!isOwner[owner], "Owner not unique");
            
            isOwner[owner] = true;
            owners.push(owner);
        }
        
        required = _required;
    }
    
    function executeTransaction(
        address to,
        uint256 value,
        bytes memory data,
        bytes[] memory signatures
    ) public {
        require(signatures.length >= required, "Not enough signatures");
        
        Transaction memory txn = Transaction({
            to: to,
            value: value,
            data: data,
            nonce: nonce
        });
        
        bytes32 txnHash = keccak256(abi.encode(txn));
        
        // EIP-191格式：使用合约地址作为验证器
        bytes32 message = keccak256(abi.encodePacked(
            bytes1(0x19),
            bytes1(0x00),
            address(this),  // 验证器地址
            txnHash
        ));
        
        address[] memory signers = new address[](signatures.length);
        
        // 验证所有签名
        for (uint256 i = 0; i < signatures.length; i++) {
            address signer = message.recover(signatures[i]);
            require(isOwner[signer], "Invalid signer");
            
            // 检查重复签名
            for (uint256 j = 0; j < i; j++) {
                require(signers[j] != signer, "Duplicate signature");
            }
            
            signers[i] = signer;
        }
        
        nonce++;
        
        // 执行交易
        (bool success,) = to.call{value: value}(data);
        require(success, "Transaction failed");
    }
}
```

## 安全机制与防护

### 1. 防重放攻击
```solidity
// 通过nonce机制防止重放攻击
mapping(bytes32 => bool) public usedHashes;

function executeWithNonce(
    bytes32 dataHash,
    uint256 userNonce,
    bytes memory signature
) external {
    bytes32 message = keccak256(abi.encodePacked(
        bytes1(0x19),
        bytes1(0x00),
        address(this),
        dataHash,
        userNonce
    ));
    
    require(!usedHashes[message], "Hash already used");
    usedHashes[message] = true;
    
    // 验证签名并执行逻辑...
}
```

### 2. 域隔离
```javascript
// 不同应用使用不同的验证器地址
const appAValidator = "0x123...";  // 应用A的验证器
const appBValidator = "0x456...";  // 应用B的验证器

// 应用A的签名无法在应用B中使用
const messageA = EIP191Handler.createValidatorMessage(appAValidator, data);
const messageB = EIP191Handler.createValidatorMessage(appBValidator, data);
// messageA !== messageB，防止跨应用重放
```

### 3. 时间窗口限制
```solidity
struct TimedMessage {
    bytes32 dataHash;
    uint256 validUntil;
    uint256 nonce;
}

function executeTimedMessage(
    TimedMessage memory message,
    bytes memory signature
) external {
    require(block.timestamp <= message.validUntil, "Message expired");
    
    bytes32 hash = keccak256(abi.encodePacked(
        bytes1(0x19),
        bytes1(0x00),
        address(this),
        abi.encode(message)
    ));
    
    // 验证签名并执行...
}
```

## 应用场景

### 1. 钱包集成
```javascript
// MetaMask个人签名
const signature = await ethereum.request({
    method: 'personal_sign',
    params: [message, account]
});

// 等价于EIP-191版本0x45格式
const messageHash = ethers.utils.hashMessage(message);
```

### 2. DApp身份验证
```javascript
class DAppAuth {
    static async generateAuthMessage(userAddress, timestamp) {
        const message = {
            address: userAddress,
            timestamp: timestamp,
            action: "login"
        };
        
        return EIP191Handler.createValidatorMessage(
            "0x验证器合约地址",
            JSON.stringify(message)
        );
    }
    
    static async verifyLogin(signature, userAddress) {
        const timestamp = Date.now();
        const messageHash = await this.generateAuthMessage(userAddress, timestamp);
        
        return EIP191Handler.verifySignature(
            messageHash,
            signature,
            userAddress
        );
    }
}
```

### 3. 链下订单签名
```solidity
contract OrderBook {
    struct Order {
        address maker;
        address taker;
        uint256 amount;
        uint256 price;
        uint256 expiry;
        uint256 nonce;
    }
    
    function executeOrder(
        Order memory order,
        bytes memory signature
    ) external {
        require(block.timestamp <= order.expiry, "Order expired");
        
        bytes32 orderHash = keccak256(abi.encode(order));
        bytes32 message = keccak256(abi.encodePacked(
            bytes1(0x19),
            bytes1(0x00),
            address(this),
            orderHash
        ));
        
        address recovered = message.recover(signature);
        require(recovered == order.maker, "Invalid signature");
        
        // 执行订单逻辑...
    }
}
```

## 与其他EIP的关系

### EIP-191 → EIP-712
```javascript
// EIP-712使用EIP-191的版本0x01
const eip712Hash = ethers.utils._TypedDataEncoder.hash(domain, types, value);
// 实际上是：keccak256(0x19 0x01 domainSeparator hashStruct(message))
```

### EIP-191 → EIP-1271
```solidity
// 智能合约签名验证
function isValidSignature(
    bytes32 hash,
    bytes memory signature
) external view returns (bytes4) {
    bytes32 message = keccak256(abi.encodePacked(
        bytes1(0x19),
        bytes1(0x00),
        address(this),
        hash
    ));
    
    if (verifySignature(message, signature)) {
        return 0x1626ba7e;  // EIP-1271魔术值
    }
    return 0xffffffff;
}
```

## 最佳实践

### 1. 版本选择指南
- **版本0x00**：用于智能合约验证、多重签名场景
- **版本0x01**：用于复杂结构化数据（配合EIP-712）
- **版本0x45**：用于简单消息签名、用户身份验证

### 2. 安全实现要点
```javascript
// ✅ 正确实现
function secureSignatureVerification(message, signature, expectedSigner) {
    try {
        // 使用EIP-191标准格式
        const formattedMessage = EIP191Handler.createValidatorMessage(
            contractAddress,
            message
        );
        
        // 验证签名
        return EIP191Handler.verifySignature(
            formattedMessage,
            signature,
            expectedSigner
        );
    } catch (error) {
        console.error('签名验证错误:', error);
        return false;
    }
}

// ❌ 不安全实现
function insecureVerification(message, signature) {
    // 直接对原始消息进行签名验证，缺乏EIP-191保护
    const hash = ethers.utils.keccak256(message);
    return ethers.utils.recoverAddress(hash, signature);
}
```

### 3. 错误处理
```javascript
class SignatureError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
    }
}

function handleSignatureVerification(messageHash, signature, expectedSigner) {
    try {
        const recovered = ethers.utils.recoverAddress(messageHash, signature);
        
        if (recovered.toLowerCase() !== expectedSigner.toLowerCase()) {
            throw new SignatureError('INVALID_SIGNER', '签名者地址不匹配');
        }
        
        return true;
    } catch (error) {
        if (error.code === 'INVALID_ARGUMENT') {
            throw new SignatureError('MALFORMED_SIGNATURE', '签名格式错误');
        } else if (error.code === 'INVALID_SIGNER') {
            throw error;
        } else {
            throw new SignatureError('VERIFICATION_FAILED', '签名验证失败');
        }
    }
}
```

## 总结

EIP-191是以太坊签名生态系统的基础标准，它：

- **提供安全基础**：通过0x19前缀防止RLP混淆和交易重放
- **支持版本扩展**：灵活的版本机制支持不同应用场景
- **确保兼容性**：为其他签名标准（如EIP-712）提供基础
- **增强安全性**：通过验证器地址隔离不同应用域

正确理解和实现EIP-191对于构建安全的区块链应用至关重要，它是现代以太坊签名标准的基石。