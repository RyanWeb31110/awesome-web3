# EIP-712 类型化结构数据签名

## 概述

EIP-712是以太坊改进提案，定义了一种对类型化结构数据进行哈希和签名的标准。与传统的字节串签名不同，EIP-712提供了一种更安全、用户友好的方式来处理结构化数据的签名。

## 背景与动机

### 现有问题
在EIP-712之前，用户在签名时只能看到一串不可读的十六进制字符串，无法了解自己正在签署什么内容。这带来了严重的安全隐患：
- 用户体验差：无法理解签名内容
- 安全风险高：容易被恶意应用欺骗
- 缺乏标准化：不同应用有不同的实现方式

### EIP-712的解决方案
EIP-712通过以下方式解决了这些问题：
1. **结构化数据展示**：将签名数据以可读的结构化形式展示给用户
2. **类型安全**：定义了严格的数据类型系统
3. **防重放攻击**：通过域分隔符防止跨域重放攻击
4. **标准化**：提供统一的实现标准

## 核心概念

### 1. 类型化数据（Typed Data）
EIP-712定义了一套类型系统，支持以下数据类型：

#### 原子类型
- `bytes1` 到 `bytes32`：固定长度字节数组
- `uint8` 到 `uint256`：无符号整数
- `int8` 到 `int256`：有符号整数
- `bool`：布尔值
- `address`：以太坊地址

#### 复合类型
- `bytes`：动态字节数组
- `string`：字符串
- `T[]`：动态数组
- `T[k]`：固定长度数组（k为正整数）
- 结构体：自定义数据结构

### 2. 域分隔符（Domain Separator）
域分隔符是EIP-712的核心安全机制，用于防止签名在不同应用或链之间被重用。

```javascript
const domain = {
    name: "MyDApp",                    // 应用名称
    version: "1",                      // 版本号
    chainId: 1,                        // 链ID（主网=1）
    verifyingContract: "0x123..."      // 验证合约地址
};
```

### 3. 类型哈希（Type Hash）
每个结构体类型都有一个唯一的类型哈希，用于标识该类型的结构。

```solidity
// 对于Person结构体
struct Person {
    string name;
    address wallet;
}

// 类型哈希为：
keccak256("Person(string name,address wallet)")
```

## 编码规范

### 1. 结构体编码
```solidity
// 示例：邮件结构体
struct Mail {
    Person from;
    Person to;
    string contents;
}

struct Person {
    string name;
    address wallet;
}
```

### 2. 类型字符串生成
```javascript
// Mail的类型字符串
"Mail(Person from,Person to,string contents)Person(string name,address wallet)"
```

### 3. 编码函数
```solidity
function hashStruct(Mail memory mail) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        keccak256("Mail(Person from,Person to,string contents)Person(string name,address wallet)"),
        hashStruct(mail.from),
        hashStruct(mail.to),
        keccak256(bytes(mail.contents))
    ));
}
```

## 实际代码示例

### 1. JavaScript实现
```javascript
const ethers = require('ethers');

// 定义域信息
const domain = {
    name: "Ether Mail",
    version: "1",
    chainId: 1,
    verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
};

// 定义数据类型
const types = {
    Person: [
        { name: "name", type: "string" },
        { name: "wallet", type: "address" }
    ],
    Mail: [
        { name: "from", type: "Person" },
        { name: "to", type: "Person" },
        { name: "contents", type: "string" }
    ]
};

// 要签名的数据
const value = {
    from: {
        name: "Cow",
        wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
    },
    to: {
        name: "Bob",
        wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"
    },
    contents: "Hello, Bob!"
};

// 签名
async function signTypedData(signer) {
    const signature = await signer._signTypedData(domain, types, value);
    return signature;
}
```

### 2. Solidity验证合约
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";

contract MailContract is EIP712 {
    using ECDSA for bytes32;

    struct Person {
        string name;
        address wallet;
    }

    struct Mail {
        Person from;
        Person to;
        string contents;
    }

    bytes32 private constant MAIL_TYPEHASH = 
        keccak256("Mail(Person from,Person to,string contents)Person(string name,address wallet)");
    
    bytes32 private constant PERSON_TYPEHASH = 
        keccak256("Person(string name,address wallet)");

    constructor() EIP712("Ether Mail", "1") {}

    function hashPerson(Person memory person) internal pure returns (bytes32) {
        return keccak256(abi.encode(
            PERSON_TYPEHASH,
            keccak256(bytes(person.name)),
            person.wallet
        ));
    }

    function hashMail(Mail memory mail) internal pure returns (bytes32) {
        return keccak256(abi.encode(
            MAIL_TYPEHASH,
            hashPerson(mail.from),
            hashPerson(mail.to),
            keccak256(bytes(mail.contents))
        ));
    }

    function verify(Mail memory mail, bytes memory signature) public view returns (address) {
        bytes32 digest = _hashTypedDataV4(hashMail(mail));
        return digest.recover(signature);
    }
}
```

### 3. Web3.js完整示例
```javascript
const Web3 = require('web3');
const web3 = new Web3('http://localhost:8545');

const typedData = {
    types: {
        EIP712Domain: [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'address' },
        ],
        Person: [
            { name: 'name', type: 'string' },
            { name: 'wallet', type: 'address' },
        ],
        Mail: [
            { name: 'from', type: 'Person' },
            { name: 'to', type: 'Person' },
            { name: 'contents', type: 'string' },
        ],
    },
    primaryType: 'Mail',
    domain: {
        name: 'Ether Mail',
        version: '1',
        chainId: 1,
        verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
    },
    message: {
        from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        contents: 'Hello, Bob!',
    },
};

// 签名
async function signMessage(account) {
    try {
        const signature = await web3.currentProvider.request({
            method: 'eth_signTypedData_v4',
            params: [account, JSON.stringify(typedData)],
            from: account,
        });
        return signature;
    } catch (error) {
        console.error('签名失败:', error);
    }
}
```

## 安全特性

### 1. 防重放攻击
通过域分隔符确保签名只在特定的应用和链上有效：
```javascript
const domain = {
    name: "MyApp",        // 应用标识
    version: "1.0",       // 版本控制
    chainId: 1,           // 链ID防止跨链重放
    verifyingContract: "0x..."  // 合约地址
};
```

### 2. 类型安全
严格的类型检查防止数据被错误解释：
```solidity
struct Transfer {
    address to;      // 必须是有效地址
    uint256 amount;  // 必须是正整数
    uint256 nonce;   // 防止重放的随机数
}
```

### 3. 结构化验证
钱包可以向用户展示清晰的签名内容：
```
签名请求：
发送人: Alice (0x123...)
接收人: Bob (0x456...)
金额: 100 ETH
用途: 购买NFT
```

## 应用场景

### 1. 去中心化交易所
```solidity
struct Order {
    address maker;
    address taker;
    address baseToken;
    address quoteToken;
    uint256 baseAmount;
    uint256 quoteAmount;
    uint256 expiry;
    uint256 nonce;
}
```

### 2. 多重签名钱包
```solidity
struct Transaction {
    address to;
    uint256 value;
    bytes data;
    uint256 nonce;
    uint256 expiry;
}
```

### 3. DeFi协议授权
```solidity
struct Permit {
    address owner;
    address spender;
    uint256 value;
    uint256 nonce;
    uint256 deadline;
}
```

### 4. NFT市场
```solidity
struct Listing {
    address seller;
    address nftContract;
    uint256 tokenId;
    uint256 price;
    uint256 expiry;
}
```

## 实现注意事项

### 1. 类型哈希计算
确保类型字符串的格式正确：
```javascript
// 正确
"Mail(Person from,Person to,string contents)Person(string name,address wallet)"

// 错误：缺少依赖类型
"Mail(Person from,Person to,string contents)"
```

### 2. 编码顺序
结构体成员必须按照定义顺序进行编码：
```solidity
struct Person {
    string name;    // 第一个
    address wallet; // 第二个
}

// 编码时必须保持顺序
abi.encode(PERSON_TYPEHASH, keccak256(bytes(name)), wallet)
```

### 3. 字符串和字节数组处理
动态数据需要先计算哈希：
```solidity
// 字符串
keccak256(bytes(stringValue))

// 动态字节数组
keccak256(bytesValue)
```

## 最佳实践

### 1. 域分隔符设计
```javascript
const domain = {
    name: "MyDApp",                    // 使用描述性名称
    version: "1.0.0",                  // 语义化版本
    chainId: await web3.eth.getChainId(), // 动态获取链ID
    verifyingContract: contractAddress  // 实际合约地址
};
```

### 2. 结构体设计
```solidity
struct Order {
    address maker;      // 关键身份信息
    uint256 nonce;      // 防重放
    uint256 expiry;     // 时间限制
    bytes32 orderHash;  // 订单标识
}
```

### 3. 错误处理
```javascript
async function safeSignTypedData(signer, domain, types, value) {
    try {
        return await signer._signTypedData(domain, types, value);
    } catch (error) {
        if (error.code === 4001) {
            throw new Error('用户取消签名');
        } else if (error.code === -32602) {
            throw new Error('参数格式错误');
        } else {
            throw new Error(`签名失败: ${error.message}`);
        }
    }
}
```

## EIP-712结构一致性与数据完整性保障机制

### 1. 类型哈希（Type Hash）保证结构一致性

#### 类型哈希计算机制
```solidity
// 示例结构体
struct Person {
    string name;
    address wallet;
}

struct Mail {
    Person from;
    Person to;
    string contents;
}

// 类型字符串生成规则：
// 1. 主类型在前：Mail(Person from,Person to,string contents)
// 2. 依赖类型按字典序排列：Person(string name,address wallet)
// 最终类型字符串：
"Mail(Person from,Person to,string contents)Person(string name,address wallet)"

// 类型哈希计算
bytes32 MAIL_TYPEHASH = keccak256(
    "Mail(Person from,Person to,string contents)Person(string name,address wallet)"
);
```

#### 结构一致性验证
```javascript
// 如果有人试图修改结构定义
const maliciousTypes = {
    Mail: [
        { name: "from", type: "Person" },
        { name: "to", type: "Person" },
        { name: "contents", type: "string" },
        { name: "amount", type: "uint256" }  // ❌ 恶意添加字段
    ]
};

// 生成的类型哈希会完全不同
const originalTypeHash = keccak256("Mail(Person from,Person to,string contents)Person(string name,address wallet)");
const maliciousTypeHash = keccak256("Mail(Person from,Person to,string contents,uint256 amount)Person(string name,address wallet)");

// originalTypeHash !== maliciousTypeHash
// 签名验证会失败，确保结构一致性
```

### 2. 严格的编码规则保证数据完整性

#### 字段顺序强制性
```solidity
// 编码必须严格按照结构体定义的顺序
function hashPerson(Person memory person) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        PERSON_TYPEHASH,
        keccak256(bytes(person.name)),    // 第1个字段：name
        person.wallet                     // 第2个字段：wallet
    ));
    
    // ❌ 错误的顺序会导致不同的哈希
    // return keccak256(abi.encode(
    //     PERSON_TYPEHASH,
    //     person.wallet,                 // 顺序错误
    //     keccak256(bytes(person.name))  // 顺序错误
    // ));
}
```

#### 类型特定的编码规则
```solidity
function hashMail(Mail memory mail) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        MAIL_TYPEHASH,
        hashPerson(mail.from),           // 嵌套结构体：递归哈希
        hashPerson(mail.to),             // 嵌套结构体：递归哈希
        keccak256(bytes(mail.contents))  // 动态类型：先哈希再编码
    ));
}
```

### 3. 域分隔符（Domain Separator）提供上下文隔离

#### 域分隔符构造
```javascript
const domain = {
    name: "Ether Mail",              // 应用名称
    version: "1",                    // 版本号
    chainId: 1,                      // 链ID
    verifyingContract: "0xCcCc..."   // 合约地址
};

// 域分隔符哈希
const domainSeparator = ethers.utils._TypedDataEncoder.hashDomain(domain);

// 实际计算过程
const DOMAIN_TYPEHASH = keccak256(
    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
);

const domainHash = keccak256(abi.encode(
    DOMAIN_TYPEHASH,
    keccak256(bytes(domain.name)),
    keccak256(bytes(domain.version)),
    domain.chainId,
    domain.verifyingContract
));
```

#### 跨域防护验证
```solidity
// 不同域的相同数据会产生不同的最终哈希
bytes32 digest1 = keccak256(abi.encodePacked(
    "\x19\x01",           // EIP-191前缀
    domainSeparator1,     // 域1
    structHash           // 相同的结构哈希
));

bytes32 digest2 = keccak256(abi.encodePacked(
    "\x19\x01",           // EIP-191前缀
    domainSeparator2,     // 域2（不同）
    structHash           // 相同的结构哈希
));

// digest1 !== digest2，防止跨域重放攻击
```

### 4. 完整的验证链条

#### 完整的哈希验证流程
```javascript
class EIP712Validator {
    static validateStructure(domain, types, value) {
        // 1. 验证类型定义完整性
        this.validateTypeDefinitions(types);
        
        // 2. 验证数据与类型匹配
        this.validateDataTypes(types, value);
        
        // 3. 验证字段完整性
        this.validateRequiredFields(types, value);
        
        return true;
    }
    
    static validateTypeDefinitions(types) {
        for (const [typeName, fields] of Object.entries(types)) {
            if (typeName === 'EIP712Domain') continue;
            
            // 验证字段定义
            for (const field of fields) {
                if (!field.name || !field.type) {
                    throw new Error(`Invalid field definition in ${typeName}`);
                }
                
                // 验证引用类型存在
                if (this.isReferenceType(field.type) && !types[field.type]) {
                    throw new Error(`Referenced type ${field.type} not found`);
                }
            }
        }
    }
    
    static validateDataTypes(types, value, typeName = 'primary') {
        const typeDefinition = types[typeName];
        
        for (const field of typeDefinition) {
            const fieldValue = value[field.name];
            
            // 验证必填字段
            if (fieldValue === undefined) {
                throw new Error(`Missing required field: ${field.name}`);
            }
            
            // 验证类型匹配
            if (!this.isValidType(fieldValue, field.type)) {
                throw new Error(`Type mismatch for field ${field.name}: expected ${field.type}`);
            }
            
            // 递归验证嵌套结构
            if (types[field.type]) {
                this.validateDataTypes(types, fieldValue, field.type);
            }
        }
    }
}
```

#### 实际应用中的安全检查
```solidity
contract SecureMailContract {
    // 存储已验证的类型哈希
    mapping(bytes32 => bool) public validTypeHashes;
    
    // 存储域分隔符
    bytes32 public immutable DOMAIN_SEPARATOR;
    
    constructor() {
        // 在部署时固定域分隔符
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
            keccak256(bytes("Secure Mail")),
            keccak256(bytes("1")),
            block.chainid,
            address(this)
        ));
        
        // 注册有效的类型哈希
        validTypeHashes[keccak256("Mail(Person from,Person to,string contents)Person(string name,address wallet)")] = true;
    }
    
    function verifyMail(
        Mail memory mail,
        bytes32 providedTypeHash,
        bytes memory signature
    ) external view returns (address signer) {
        // 1. 验证类型哈希
        require(validTypeHashes[providedTypeHash], "Invalid type hash");
        
        // 2. 计算结构哈希
        bytes32 structHash = keccak256(abi.encode(
            providedTypeHash,
            hashPerson(mail.from),
            hashPerson(mail.to),
            keccak256(bytes(mail.contents))
        ));
        
        // 3. 构造最终摘要
        bytes32 digest = keccak256(abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR,
            structHash
        ));
        
        // 4. 恢复签名者
        return ECDSA.recover(digest, signature);
    }
}
```

### 5. 防篡改机制

#### 哈希链保护
```javascript
// 任何数据的微小变化都会导致完全不同的哈希
const originalMail = {
    from: { name: "Alice", wallet: "0x123..." },
    to: { name: "Bob", wallet: "0x456..." },
    contents: "Hello, Bob!"
};

const tamperedMail = {
    from: { name: "Alice", wallet: "0x123..." },
    to: { name: "Bob", wallet: "0x456..." },
    contents: "Hello, Bob! Send me 1 ETH."  // 篡改内容
};

// 生成不同的哈希，签名验证失败
const originalHash = ethers.utils._TypedDataEncoder.hash(domain, types, originalMail);
const tamperedHash = ethers.utils._TypedDataEncoder.hash(domain, types, tamperedMail);

console.log(originalHash === tamperedHash); // false
```

#### 类型系统保护
```javascript
// 类型不匹配会被检测到
const invalidData = {
    from: { name: "Alice", wallet: "invalid_address" },  // ❌ 无效地址格式
    to: { name: "Bob", wallet: "0x456..." },
    contents: 12345  // ❌ 应该是string类型
};

// ethers.js会在编码前验证类型
try {
    ethers.utils._TypedDataEncoder.hash(domain, types, invalidData);
} catch (error) {
    console.log("Type validation failed:", error.message);
}
```

### 6. 安全机制总结

EIP-712通过以下层次化的安全机制保证结构一致性和数据完整性：

1. **类型哈希层**：确保结构定义不被篡改
2. **编码层**：保证数据按正确顺序和类型编码
3. **域隔离层**：防止跨应用/跨链重放攻击
4. **哈希链层**：任何数据变化都会被检测到
5. **类型系统层**：编译时和运行时的类型验证

## 总结

EIP-712是现代DApp开发中的重要标准，它：
- 提供了安全的结构化数据签名方案
- 改善了用户体验和安全性
- 建立了行业标准化规范
- 支持复杂的数据结构和类型
- 通过多层安全机制保证数据完整性和结构一致性

正确实现EIP-712可以显著提高DApp的安全性和用户友好性，是区块链开发者必须掌握的重要技术。